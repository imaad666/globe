"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vis.gl";
exports.ids = ["vendor-chunks/@vis.gl"];
exports.modules = {

/***/ "(ssr)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: () => (/* binding */ APILoadingStatus),\n/* harmony export */   APIProvider: () => (/* binding */ APIProvider),\n/* harmony export */   APIProviderContext: () => (/* binding */ APIProviderContext),\n/* harmony export */   AdvancedMarker: () => (/* binding */ AdvancedMarker),\n/* harmony export */   AdvancedMarkerAnchorPoint: () => (/* binding */ AdvancedMarkerAnchorPoint),\n/* harmony export */   AdvancedMarkerContext: () => (/* binding */ AdvancedMarkerContext),\n/* harmony export */   CollisionBehavior: () => (/* binding */ CollisionBehavior),\n/* harmony export */   ColorScheme: () => (/* binding */ ColorScheme),\n/* harmony export */   ControlPosition: () => (/* binding */ ControlPosition),\n/* harmony export */   GoogleMapsContext: () => (/* binding */ GoogleMapsContext),\n/* harmony export */   InfoWindow: () => (/* binding */ InfoWindow),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapControl: () => (/* binding */ MapControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   Pin: () => (/* binding */ Pin),\n/* harmony export */   RenderingType: () => (/* binding */ RenderingType),\n/* harmony export */   StaticMap: () => (/* binding */ StaticMap),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   createStaticMapsUrl: () => (/* binding */ createStaticMapsUrl),\n/* harmony export */   isAdvancedMarker: () => (/* binding */ isAdvancedMarker),\n/* harmony export */   isLatLngLiteral: () => (/* binding */ isLatLngLiteral),\n/* harmony export */   latLngEquals: () => (/* binding */ latLngEquals),\n/* harmony export */   limitTiltRange: () => (/* binding */ limitTiltRange),\n/* harmony export */   toLatLngLiteral: () => (/* binding */ toLatLngLiteral),\n/* harmony export */   useAdvancedMarkerRef: () => (/* binding */ useAdvancedMarkerRef),\n/* harmony export */   useApiIsLoaded: () => (/* binding */ useApiIsLoaded),\n/* harmony export */   useApiLoadingStatus: () => (/* binding */ useApiLoadingStatus),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useMapsLibrary: () => (/* binding */ useMapsLibrary),\n/* harmony export */   useMarkerRef: () => (/* binding */ useMarkerRef)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/./node_modules/fast-deep-equal/index.js\");\n\n\n\n\n// This file is automatically updated by the build process.\nconst VERSION = '1.7.1';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst APILoadingStatus = {\n    NOT_LOADED: 'NOT_LOADED',\n    LOADING: 'LOADING',\n    LOADED: 'LOADED',\n    FAILED: 'FAILED',\n    AUTH_FAILURE: 'AUTH_FAILURE'\n};\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nclass GoogleMapsApiLoader {\n    /**\n     * Loads the Maps JavaScript API with the specified parameters.\n     * Since the Maps library can only be loaded once per page, this will\n     * produce a warning when called multiple times with different\n     * parameters.\n     *\n     * The returned promise resolves when loading completes\n     * and rejects in case of an error or when the loading was aborted.\n     */\n    static load(params, onLoadingStatusChange) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const libraries = params.libraries ? params.libraries.split(',') : [];\n            const serializedParams = this.serializeParams(params);\n            this.listeners.push(onLoadingStatusChange);\n            // Note: if `google.maps.importLibrary` has been defined externally, we\n            //   assume that loading is complete and successful.\n            //   If it was defined by a previous call to this method, a warning\n            //   message is logged if there are differences in api-parameters used\n            //   for both calls.\n            if ((_b = (_a = window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary) {\n                // no serialized parameters means it was loaded externally\n                if (!this.serializedApiParams) {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                }\n                this.notifyLoadingStatusListeners();\n            }\n            else {\n                this.serializedApiParams = serializedParams;\n                this.initImportLibrary(params);\n            }\n            if (this.serializedApiParams &&\n                this.serializedApiParams !== serializedParams) {\n                console.warn(`[google-maps-api-loader] The maps API has already been loaded ` +\n                    `with different parameters and will not be loaded again. Refresh the ` +\n                    `page for new values to have effect.`);\n            }\n            const librariesToLoad = ['maps', ...libraries];\n            yield Promise.all(librariesToLoad.map(name => google.maps.importLibrary(name)));\n        });\n    }\n    /**\n     * Serialize the parameters used to load the library for easier comparison.\n     */\n    static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join('/');\n    }\n    /**\n     * Creates the global `google.maps.importLibrary` function for bootstrapping.\n     * This is essentially a formatted version of the dynamic loading script\n     * from the official documentation with some minor adjustments.\n     *\n     * The created importLibrary function will load the Google Maps JavaScript API,\n     * which will then replace the `google.maps.importLibrary` function with the full\n     * implementation.\n     *\n     * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n     */\n    static initImportLibrary(params) {\n        if (!window.google)\n            window.google = {};\n        if (!window.google.maps)\n            window.google.maps = {};\n        if (window.google.maps['importLibrary']) {\n            console.error('[google-maps-api-loader-internal]: initImportLibrary must only be called once');\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = () => {\n            if (apiPromise)\n                return apiPromise;\n            apiPromise = new Promise((resolve, reject) => {\n                var _a;\n                const scriptElement = document.createElement('script');\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)) {\n                    const urlParamName = key.replace(/[A-Z]/g, t => '_' + t[0].toLowerCase());\n                    urlParams.set(urlParamName, String(value));\n                }\n                urlParams.set('loading', 'async');\n                urlParams.set('callback', '__googleMapsCallback__');\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n                scriptElement.nonce =\n                    ((_a = document.querySelector('script[nonce]')) === null || _a === void 0 ? void 0 : _a.nonce) || '';\n                scriptElement.onerror = () => {\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    this.notifyLoadingStatusListeners();\n                    reject(new Error('The Google Maps JavaScript API could not load.'));\n                };\n                window.__googleMapsCallback__ = () => {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    this.notifyLoadingStatusListeners();\n                    resolve();\n                };\n                window.gm_authFailure = () => {\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    this.notifyLoadingStatusListeners();\n                };\n                this.loadingStatus = APILoadingStatus.LOADING;\n                this.notifyLoadingStatusListeners();\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = libraryName => loadApi().then(() => google.maps.importLibrary(libraryName));\n    }\n    /**\n     * Calls all registered loadingStatusListeners after a status update.\n     */\n    static notifyLoadingStatusListeners() {\n        for (const fn of this.listeners) {\n            fn(this.loadingStatus);\n        }\n    }\n}\n/**\n * The current loadingStatus of the API.\n */\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * A list of functions to be notified when the loading status changes.\n */\nGoogleMapsApiLoader.listeners = [];\n\nconst DEFAULT_SOLUTION_CHANNEL = 'GMP_visgl_rgmlibrary_v1_default';\nconst DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS = [\n    `gmp_visgl_reactgooglemaps_v${VERSION}`\n];\nconst APIProviderContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = (mapInstance, id = 'default') => {\n        setMapInstances(instances => (Object.assign(Object.assign({}, instances), { [id]: mapInstance })));\n    };\n    const removeMapInstance = (id = 'default') => {\n        setMapInstances((_a) => {\n            var _b = id; _a[_b]; var remaining = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n            return remaining;\n        });\n    };\n    const clearMapInstances = () => {\n        setMapInstances({});\n    };\n    return { mapInstances, addMapInstance, removeMapInstance, clearMapInstances };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props) {\n    const { onLoad, onError, apiKey, version, libraries = [] } = props, otherApiParams = __rest(props, [\"onLoad\", \"onError\", \"apiKey\", \"version\", \"libraries\"]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action) => {\n        return loadedLibraries[action.name]\n            ? loadedLibraries\n            : Object.assign(Object.assign({}, loadedLibraries), { [action.name]: action.value });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => libraries === null || libraries === void 0 ? void 0 : libraries.join(','), [libraries]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => JSON.stringify(Object.assign({ apiKey, version }, otherApiParams)), [apiKey, version, otherApiParams]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        if (loadedLibraries[name]) {\n            return loadedLibraries[name];\n        }\n        if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.importLibrary)) {\n            throw new Error('[api-provider-internal] importLibrary was called before ' +\n                'google.maps.importLibrary was defined.');\n        }\n        const res = yield window.google.maps.importLibrary(name);\n        addLoadedLibrary({ name, value: res });\n        return res;\n    }), [loadedLibraries]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (() => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const params = Object.assign({ key: apiKey }, otherApiParams);\n                if (version)\n                    params.v = version;\n                if ((librariesString === null || librariesString === void 0 ? void 0 : librariesString.length) > 0)\n                    params.libraries = librariesString;\n                if (params.channel === undefined ||\n                    params.channel < 0 ||\n                    params.channel > 999)\n                    delete params.channel;\n                if (params.solutionChannel === undefined)\n                    params.solutionChannel = DEFAULT_SOLUTION_CHANNEL;\n                else if (params.solutionChannel === '')\n                    delete params.solutionChannel;\n                yield GoogleMapsApiLoader.load(params, status => setStatus(status));\n                for (const name of ['core', 'maps', ...libraries]) {\n                    yield importLibrary(name);\n                }\n                if (onLoad) {\n                    onLoad();\n                }\n            }\n            catch (error) {\n                if (onError) {\n                    onError(error);\n                }\n                else {\n                    console.error('<ApiProvider> failed to load the Google Maps JavaScript API', error);\n                }\n            }\n        }))();\n    }, \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [apiKey, librariesString, serializedParams]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\nfunction useInternalUsageAttributionIds(props) {\n    const internalUsageAttributionIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => props.disableUsageAttribution\n        ? null\n        : DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS, [props.disableUsageAttribution]);\n    return internalUsageAttributionIds;\n}\n/**\n * Component to wrap the components from this library and load the Google Maps JavaScript API\n */\nconst APIProvider = props => {\n    const { children } = props, loaderProps = __rest(props, [\"children\"]);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    const internalUsageAttributionIds = useInternalUsageAttributionIds(loaderProps);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    }), [\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    ]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, { value: contextValue }, children));\n};\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nfunction useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames) {\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n            if (!map)\n                return;\n            if (!handler)\n                return;\n            const listener = google.maps.event.addListener(map, eventType, (ev) => {\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return () => listener.remove();\n        }, [map, eventType, handler]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(type, map, srcEvent) {\n    var _a;\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: () => { }\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn('[createEvent] at least one of the values from the map ' +\n                'returned undefined. This is not expected to happen. Please ' +\n                'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n        }\n        camEvent.detail = {\n            center: (center === null || center === void 0 ? void 0 : center.toJSON()) || { lat: 0, lng: 0 },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds === null || bounds === void 0 ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    }\n    else if (mouseEventTypes.includes(type)) {\n        if (!srcEvent)\n            throw new Error('[createEvent] mouse events must provide a srcEvent');\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = () => srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_a = srcEvent.latLng) === null || _a === void 0 ? void 0 : _a.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType = {\n    onBoundsChanged: 'bounds_changed',\n    onCenterChanged: 'center_changed',\n    onClick: 'click',\n    onContextmenu: 'contextmenu',\n    onDblclick: 'dblclick',\n    onDrag: 'drag',\n    onDragend: 'dragend',\n    onDragstart: 'dragstart',\n    onHeadingChanged: 'heading_changed',\n    onIdle: 'idle',\n    onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n    onMapCapabilitiesChanged: 'mapcapabilities_changed',\n    onMapTypeIdChanged: 'maptypeid_changed',\n    onMousemove: 'mousemove',\n    onMouseout: 'mouseout',\n    onMouseover: 'mouseover',\n    onProjectionChanged: 'projection_changed',\n    onRenderingTypeChanged: 'renderingtype_changed',\n    onTilesLoaded: 'tilesloaded',\n    onTiltChanged: 'tilt_changed',\n    onZoomChanged: 'zoom_changed',\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: 'bounds_changed'\n};\nconst cameraEventTypes = [\n    'bounds_changed',\n    'center_changed',\n    'heading_changed',\n    'tilt_changed',\n    'zoom_changed'\n];\nconst mouseEventTypes = [\n    'click',\n    'contextmenu',\n    'dblclick',\n    'mousemove',\n    'mouseout',\n    'mouseover'\n];\nconst eventPropNames = Object.keys(propNameToEventType);\n\n/**\n * A hook to store the previous value of a variable.\n * @param value The value to store\n * @returns The previous value\n */\nfunction usePrevious(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        ref.current = value;\n    });\n    // eslint-disable-next-line react-hooks/refs\n    return ref.current;\n}\n\nfunction useMemoized(value, isEqual) {\n    const previous = usePrevious(value);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (previous && isEqual(previous, value)) {\n            return previous;\n        }\n        return value;\n    }, [value, previous, isEqual]);\n}\n\nfunction useCustomCompareEffect(effect, dependencies, isEqual) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, [useMemoized(dependencies, isEqual)]);\n}\n\nfunction useDeepCompareEffect(effect, dependencies) {\n    useCustomCompareEffect(effect, dependencies, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n}\n\nconst mapOptionKeys = new Set([\n    'backgroundColor',\n    'clickableIcons',\n    'controlSize',\n    'disableDefaultUI',\n    'disableDoubleClickZoom',\n    'draggable',\n    'draggableCursor',\n    'draggingCursor',\n    'fullscreenControl',\n    'fullscreenControlOptions',\n    'gestureHandling',\n    'headingInteractionEnabled',\n    'isFractionalZoomEnabled',\n    'keyboardShortcuts',\n    'mapTypeControl',\n    'mapTypeControlOptions',\n    'mapTypeId',\n    'maxZoom',\n    'minZoom',\n    'noClear',\n    'panControl',\n    'panControlOptions',\n    'restriction',\n    'rotateControl',\n    'rotateControlOptions',\n    'scaleControl',\n    'scaleControlOptions',\n    'scrollwheel',\n    'streetView',\n    'streetViewControl',\n    'streetViewControlOptions',\n    'styles',\n    'tiltInteractionEnabled',\n    'zoomControl',\n    'zoomControlOptions'\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nfunction useMapOptions(map, mapProps) {\n    /* eslint-disable react-hooks/exhaustive-deps --\n     *\n     * The following effects aren't triggered when the map is changed.\n     * In that case, the values will be or have been passed to the map\n     * constructor via mapOptions.\n     */\n    const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys) {\n        if (!mapOptionKeys.has(key))\n            continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(() => {\n        if (!map)\n            return;\n        map.setOptions(mapOptions);\n    }, [mapOptions]);\n    /* eslint-enable react-hooks/exhaustive-deps */\n}\n\nfunction useApiLoadingStatus() {\n    var _a;\n    return ((_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) === null || _a === void 0 ? void 0 : _a.status) || APILoadingStatus.NOT_LOADED;\n}\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nfunction useDeckGLCameraUpdate(map, props) {\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (!map || !viewState)\n            return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: { lat: latitude, lng: longitude },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [map, viewState]);\n    return isDeckGlControlled;\n}\n\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== 'object')\n        return false;\n    if (!('lat' in obj && 'lng' in obj))\n        return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b)\n        return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng)\n        return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj))\n        return obj;\n    return obj.toJSON();\n}\n\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom)\n        ? mapProps.zoom\n        : null;\n    const heading = Number.isFinite(mapProps.heading)\n        ? mapProps.heading\n        : null;\n    const tilt = Number.isFinite(mapProps.tilt)\n        ? mapProps.tilt\n        : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (!map)\n            return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null &&\n            lng !== null &&\n            (cameraStateRef.current.center.lat !== lat ||\n                cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = { lat, lng };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\n\nconst AuthFailureMessage = () => {\n    const style = {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: 'flex',\n        flexFlow: 'column nowrap',\n        textAlign: 'center',\n        justifyContent: 'center',\n        fontSize: '.8rem',\n        color: 'rgba(0,0,0,0.6)',\n        background: '#dddddd',\n        padding: '1rem 1.5rem'\n    };\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: style },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null,\n            \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \",\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"),\n            \" prop is correct. Check the error-message in the console for further details.\")));\n};\n\nfunction useCallbackRef() {\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value) => setEl(value), [setEl]);\n    return [el, ref];\n}\n\n/**\n * Hook to check if the Maps JavaScript API is loaded\n */\nfunction useApiIsLoaded() {\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\n\nfunction useForceUpdate() {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(x => x + 1, 0);\n    return forceUpdate;\n}\n\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn('[useTrackedCameraState] at least one of the values from the map ' +\n            'returned undefined. This is not expected to happen. Please ' +\n            'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center === null || center === void 0 ? void 0 : center.toJSON()) || { lat: 0, lng: 0 },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */\nfunction useTrackedCameraStateRef(map) {\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: { lat: 0, lng: 0 },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map)\n            return;\n        const listener = google.maps.event.addListener(map, 'bounds_changed', () => {\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return () => listener.remove();\n    }, [map, forceUpdate]);\n    return ref;\n}\n\n/**\n * Stores a stack of map-instances for each mapId. Whenever an\n * instance is used, it is removed from the stack while in use,\n * and returned to the stack when the component unmounts.\n * This allows us to correctly implement caching for multiple\n * maps om the same page, while reusing as much as possible.\n *\n * FIXME: while it should in theory be possible to reuse maps solely\n *   based on the mapId (as all other parameters can be changed at\n *   runtime), we don't yet have good enough tracking of options to\n *   reliably unset all the options that have been set.\n */\nclass CachedMapStack {\n    static has(key) {\n        return this.entries[key] && this.entries[key].length > 0;\n    }\n    static pop(key) {\n        if (!this.entries[key])\n            return null;\n        return this.entries[key].pop() || null;\n    }\n    static push(key, value) {\n        if (!this.entries[key])\n            this.entries[key] = [];\n        this.entries[key].push(value);\n    }\n}\nCachedMapStack.entries = {};\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(props, context) {\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt, reuseMaps, renderingType, colorScheme } = props, mapOptions = __rest(props, [\"id\", \"defaultBounds\", \"defaultCenter\", \"defaultZoom\", \"defaultHeading\", \"defaultTilt\", \"reuseMaps\", \"renderingType\", \"colorScheme\"]);\n    const hasZoom = props.zoom !== undefined || props.defaultZoom !== undefined;\n    const hasCenter = props.center !== undefined || props.defaultCenter !== undefined;\n    if (!defaultBounds && (!hasZoom || !hasCenter)) {\n        console.warn('<Map> component is missing configuration. ' +\n            'You have to provide zoom and center (via the `zoom`/`defaultZoom` and ' +\n            '`center`/`defaultCenter` props) or specify the region to show using ' +\n            '`defaultBounds`. See ' +\n            'https://visgl.github.io/react-google-maps/docs/api-reference/components/map#required');\n    }\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter)\n        mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom))\n        mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading))\n        mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt))\n        mapOptions.tilt = defaultTilt;\n    // Handle internalUsageAttributionIds\n    const customIds = mapOptions.internalUsageAttributionIds;\n    if (customIds == null) {\n        // Not specified - use context default (which may be null if disabled)\n        mapOptions.internalUsageAttributionIds =\n            context.internalUsageAttributionIds;\n    }\n    else {\n        // Merge context defaults with custom IDs\n        mapOptions.internalUsageAttributionIds = [\n            ...(context.internalUsageAttributionIds || []),\n            ...customIds\n        ];\n    }\n    for (const key of Object.keys(mapOptions))\n        if (mapOptions[key] === undefined)\n            delete mapOptions[key];\n    const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!container || !apiIsLoaded)\n            return;\n        const { addMapInstance, removeMapInstance } = context;\n        // note: colorScheme (upcoming feature) isn't yet in the typings, remove once that is fixed:\n        const { mapId } = props;\n        const cacheKey = `${mapId || 'default'}:${renderingType || 'default'}:${colorScheme || 'LIGHT'}`;\n        let mapDiv;\n        let map;\n        if (reuseMaps && CachedMapStack.has(cacheKey)) {\n            map = CachedMapStack.pop(cacheKey);\n            mapDiv = map.getDiv();\n            container.appendChild(mapDiv);\n            map.setOptions(mapOptions);\n            // detaching the element from the DOM lets the map fall back to its default\n            // size, setting the center will trigger reloading the map.\n            setTimeout(() => map.setCenter(map.getCenter()), 0);\n        }\n        else {\n            mapDiv = document.createElement('div');\n            mapDiv.style.height = '100%';\n            container.appendChild(mapDiv);\n            map = new google.maps.Map(mapDiv, Object.assign(Object.assign(Object.assign({}, mapOptions), (renderingType\n                ? { renderingType: renderingType }\n                : {})), (colorScheme\n                ? { colorScheme: colorScheme }\n                : {})));\n        }\n        setMap(map);\n        addMapInstance(map, id);\n        if (defaultBounds) {\n            const { padding } = defaultBounds, defBounds = __rest(defaultBounds, [\"padding\"]);\n            map.fitBounds(defBounds, padding);\n        }\n        // prevent map not rendering due to missing configuration\n        else if (!hasZoom || !hasCenter) {\n            map.fitBounds({ east: 180, west: -180, south: -90, north: 90 });\n        }\n        // the savedMapState is used to restore the camera parameters when the mapId is changed\n        if (savedMapStateRef.current) {\n            const { mapId: savedMapId, cameraState: savedCameraState } = savedMapStateRef.current;\n            if (savedMapId !== mapId) {\n                map.setOptions(savedCameraState);\n            }\n        }\n        return () => {\n            savedMapStateRef.current = {\n                mapId,\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                cameraState: cameraStateRef.current\n            };\n            // detach the map-div from the dom\n            mapDiv.remove();\n            if (reuseMaps) {\n                // push back on the stack\n                CachedMapStack.push(cacheKey, map);\n            }\n            else {\n                // remove all event-listeners to minimize the possibility of memory-leaks\n                google.maps.event.clearInstanceListeners(map);\n            }\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, \n    // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        // these props can't be changed after initialization and require a new\n        // instance to be created\n        props.mapId,\n        props.renderingType,\n        props.colorScheme\n    ]);\n    return [map, containerRef, cameraStateRef];\n}\n\nconst GoogleMapsContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// ColorScheme and RenderingType are redefined here to make them usable before the\n// maps API has been fully loaded.\nconst ColorScheme = {\n    DARK: 'DARK',\n    LIGHT: 'LIGHT',\n    FOLLOW_SYSTEM: 'FOLLOW_SYSTEM'\n};\nconst RenderingType = {\n    VECTOR: 'VECTOR',\n    RASTER: 'RASTER',\n    UNINITIALIZED: 'UNINITIALIZED'\n};\nconst Map = (props) => {\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error('<Map> can only be used inside an <ApiProvider> component.');\n    }\n    const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map)\n            return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({ disableDefaultUI: true });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: 'none',\n                keyboardShortcuts: false\n            });\n        }\n        return () => {\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a, _b, _c;\n        return {\n            center: { lat: lat !== null && lat !== void 0 ? lat : 0, lng: lng !== null && lng !== void 0 ? lng : 0 },\n            zoom: (_a = props.zoom) !== null && _a !== void 0 ? _a : 0,\n            heading: (_b = props.heading) !== null && _b !== void 0 ? _b : 0,\n            tilt: (_c = props.tilt) !== null && _c !== void 0 ? _c : 0\n        };\n    }, [lat, lng, props.zoom, props.heading, props.tilt]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (!map || !isControlledExternally)\n            return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener('bounds_changed', () => {\n            map.moveCamera(cameraOptions);\n        });\n        return () => listener.remove();\n    }, [map, isControlledExternally, cameraOptions]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign({ width: '100%', height: '100%', position: 'relative', \n        // when using deckgl, the map should be sent to the back\n        zIndex: isDeckGlControlled ? -1 : 0 }, style)), [style, isDeckGlControlled]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ map }), [map]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: Object.assign({ position: 'relative' }, (className ? {} : combinedStyle)), className: className },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null)));\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({ ref: mapRef, \"data-testid\": 'map', style: className ? undefined : combinedStyle, className: className }, (id ? { id } : {})), map ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, { value: contextValue }, children)) : null));\n};\n// The deckGLViewProps flag here indicates to deck.gl that the Map component is\n// able to handle viewProps from deck.gl when deck.gl is used to control the map.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nMap.deckGLViewProps = true;\n\nconst shownMessages = new Set();\nfunction logErrorOnce(...args) {\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nconst useMap = (id = null) => {\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce('useMap(): failed to retrieve APIProviderContext. ' +\n            'Make sure that the <APIProvider> component exists and that the ' +\n            'component you are calling `useMap()` from is a sibling of the ' +\n            '<APIProvider>.');\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null)\n        return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map)\n        return map;\n    // finally, return the default map instance\n    return mapInstances['default'] || null;\n};\n\nfunction useMapsLibrary(name) {\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!apiIsLoaded || !ctx)\n            return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [apiIsLoaded, ctx, name]);\n    return (ctx === null || ctx === void 0 ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Internally used to bind events to Maps JavaScript API objects.\n * @internal\n */\nfunction useMapsEventListener(target, name, callback) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!target || !name || !callback)\n            return;\n        const listener = google.maps.event.addListener(target, name, callback);\n        return () => listener.remove();\n    }, [target, name, callback]);\n}\n\n/**\n * Internally used to copy values from props into API-Objects\n * whenever they change.\n *\n * @example\n *   usePropBinding(marker, 'position', position);\n *\n * @internal\n */\nfunction usePropBinding(object, prop, value) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!object)\n            return;\n        // eslint-disable-next-line react-hooks/immutability\n        object[prop] = value;\n    }, [object, prop, value]);\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Internally used to bind events to DOM nodes.\n * @internal\n */\nfunction useDomEventListener(target, name, callback) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!target || !name || !callback)\n            return;\n        target.addEventListener(name, callback);\n        return () => target.removeEventListener(name, callback);\n    }, [target, name, callback]);\n}\n\n// Global style manager to track rendered styles and avoid duplicates\nclass GlobalStyleManager {\n    constructor() {\n        this.renderedStyles = new Set();\n        this.styleElement = null;\n    }\n    getStyleElement() {\n        if (!this.styleElement) {\n            this.styleElement = document.createElement('style');\n            this.styleElement.setAttribute('data-rgm-anchor-styles', '');\n            document.head.appendChild(this.styleElement);\n        }\n        return this.styleElement;\n    }\n    addAdvancedMarkerPointerEventsOverwrite() {\n        if (this.renderedStyles.has('marker-pointer-events')) {\n            return;\n        }\n        const styleElement = this.getStyleElement();\n        styleElement.textContent += `\n      gmp-advanced-marker[data-origin='rgm'] {\n        pointer-events: none !important;\n      }\n    `;\n        this.renderedStyles.add('marker-pointer-events');\n    }\n    cleanup() {\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n            this.renderedStyles.clear();\n        }\n    }\n}\nconst globalStyleManager = new GlobalStyleManager();\n\nfunction isVersionGreaterEqual(major, minor) {\n    var _a;\n    if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.version))\n        return undefined;\n    const version = google.maps.version.split('.');\n    const currentMajor = parseInt(version[0], 10);\n    const currentMinor = parseInt(version[1], 10);\n    return (currentMajor > major || (currentMajor === major && currentMinor >= minor));\n}\n\n/* eslint-disable react-hooks/immutability */\n// The `react-hooks/immutability` rule is disabled in this file because the\n// google.maps.marker.AdvancedMarkerElement object is designed to be mutated\n// directly. This is a common pattern when working with imperative APIs like\n// the Google Maps JavaScript API. While this goes against the principles of\n// immutable state in React, it is a necessary evil to integrate with the\n// Google Maps API. The mutations are carefully managed within the `useEffect`\n// hooks to ensure that they only happen when the props change.\n/**\n * Copy of the `google.maps.CollisionBehavior` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst CollisionBehavior = {\n    REQUIRED: 'REQUIRED',\n    REQUIRED_AND_HIDES_OPTIONAL: 'REQUIRED_AND_HIDES_OPTIONAL',\n    OPTIONAL_AND_HIDES_LOWER_PRIORITY: 'OPTIONAL_AND_HIDES_LOWER_PRIORITY'\n};\nconst AdvancedMarkerContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// [xPosition, yPosition] when the top left corner is [0, 0]\n/**\n * @deprecated Using `anchorPosition` is deprecated.\n *   Use `anchorLeft` and `anchorTop` instead.\n */\nconst AdvancedMarkerAnchorPoint = {\n    TOP_LEFT: ['0%', '0%'],\n    TOP_CENTER: ['50%', '0%'],\n    TOP: ['50%', '0%'],\n    TOP_RIGHT: ['100%', '0%'],\n    LEFT_CENTER: ['0%', '50%'],\n    LEFT_TOP: ['0%', '0%'],\n    LEFT: ['0%', '50%'],\n    LEFT_BOTTOM: ['0%', '100%'],\n    RIGHT_TOP: ['100%', '0%'],\n    RIGHT: ['100%', '50%'],\n    RIGHT_CENTER: ['100%', '50%'],\n    RIGHT_BOTTOM: ['100%', '100%'],\n    BOTTOM_LEFT: ['0%', '100%'],\n    BOTTOM_CENTER: ['50%', '100%'],\n    BOTTOM: ['50%', '100%'],\n    BOTTOM_RIGHT: ['100%', '100%'],\n    CENTER: ['50%', '50%']\n};\nconst AdvancedMarker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    const { children, style, className, anchorPoint } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (marker ? { marker } : null), [marker]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n    if (!contentContainer)\n        return null;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, { value: advancedMarkerContextValue }, (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerContent, { anchorPoint: anchorPoint, styles: style, className: className }, children), contentContainer)));\n});\nAdvancedMarker.displayName = 'AdvancedMarker';\nfunction useAdvancedMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m) => {\n        setMarker(m);\n    }, []);\n    return [refCallback, marker];\n}\nfunction isAdvancedMarker(marker) {\n    return (marker.content !== undefined);\n}\nfunction isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nconst MarkerContent = ({ children, styles, className }) => {\n    /* AdvancedMarker div that user can give styles and classes */\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: className, style: styles }, children));\n};\nfunction useAdvancedMarker(props) {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const markerLibrary = useMapsLibrary('marker');\n    const { children, onClick, className, onMouseEnter, onMouseLeave, onDrag, onDragStart, onDragEnd, collisionBehavior, clickable, draggable, position, title, zIndex, anchorPoint, anchorLeft, anchorTop } = props;\n    const numChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create an AdvancedMarkerElement instance and add it to the map once available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map || !markerLibrary)\n            return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create the container for marker content if there are children\n        let contentElement = null;\n        if (numChildren > 0) {\n            contentElement = document.createElement('div');\n            newMarker.content = contentElement;\n            setContentContainer(contentElement);\n        }\n        return () => {\n            newMarker.map = null;\n            contentElement === null || contentElement === void 0 ? void 0 : contentElement.remove();\n            setMarker(null);\n            setContentContainer(null);\n        };\n    }, [map, markerLibrary, numChildren]);\n    // When no children are present we don't have our own wrapper div\n    // which usually gets the user provided className. In this case\n    // we set the className directly on the marker.content element that comes\n    // with the AdvancedMarker.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!(marker === null || marker === void 0 ? void 0 : marker.content) || !isElementNode(marker.content) || numChildren > 0)\n            return;\n        marker.content.className = className !== null && className !== void 0 ? className : '';\n    }, [marker, className, numChildren]);\n    useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, numChildren > 0);\n    // copy other props\n    usePropBinding(marker, 'position', position);\n    usePropBinding(marker, 'title', title !== null && title !== void 0 ? title : '');\n    usePropBinding(marker, 'zIndex', zIndex);\n    usePropBinding(marker, 'collisionBehavior', collisionBehavior);\n    // set gmpDraggable from props (when unspecified, it's true if any drag-event\n    // callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        if (draggable !== undefined)\n            marker.gmpDraggable = draggable;\n        else if (onDrag || onDragStart || onDragEnd)\n            marker.gmpDraggable = true;\n        else\n            marker.gmpDraggable = false;\n    }, [marker, draggable, onDrag, onDragEnd, onDragStart]);\n    // set gmpClickable from props (when unspecified, it's true if the onClick or one of\n    // the hover events callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        const gmpClickable = clickable !== undefined ||\n            Boolean(onClick) ||\n            Boolean(onMouseEnter) ||\n            Boolean(onMouseLeave);\n        // gmpClickable is only available in beta version of the\n        // maps api (as of 2024-10-10)\n        marker.gmpClickable = gmpClickable;\n        // enable pointer events for the markers with custom content\n        if (gmpClickable && (marker === null || marker === void 0 ? void 0 : marker.content) && isElementNode(marker.content)) {\n            marker.content.style.pointerEvents = 'all';\n            if (onClick) {\n                marker.content.style.cursor = 'pointer';\n            }\n        }\n    }, [marker, clickable, onClick, onMouseEnter, onMouseLeave]);\n    useMapsEventListener(marker, 'click', onClick);\n    useMapsEventListener(marker, 'drag', onDrag);\n    useMapsEventListener(marker, 'dragstart', onDragStart);\n    useMapsEventListener(marker, 'dragend', onDragEnd);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, 'mouseenter', onMouseEnter);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, 'mouseleave', onMouseLeave);\n    return [marker, contentContainer];\n}\nfunction useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, hasChildren) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker || !hasChildren)\n            return;\n        // The anchorLeft and anchorTop options are available since version 3.62.9c\n        // With the release of 3.65 (~May 2026) there will no longer be a version\n        // that doesn't support it.\n        const anchorOptionsSupported = isVersionGreaterEqual(3, 62);\n        const contentElement = marker.content;\n        if (!contentElement || !isElementNode(contentElement))\n            return;\n        if (anchorLeft !== undefined || anchorTop !== undefined) {\n            if (!anchorOptionsSupported) {\n                console.warn('AdvancedMarker: The anchorLeft and anchorTop props are only supported ' +\n                    'in Google Maps API version 3.62 and above. ' +\n                    `The current version is ${google.maps.version}.`);\n            }\n            marker.anchorLeft = anchorLeft;\n            marker.anchorTop = anchorTop;\n            // when anchorLeft and/or anchorTop are set, we'll ignore the anchorPoint\n            if (anchorPoint !== undefined) {\n                console.warn('AdvancedMarker: the anchorPoint prop is ignored when anchorLeft ' +\n                    'and/or anchorTop are set.');\n            }\n            return;\n        }\n        if (anchorPoint !== undefined) {\n            // TODO: add console.warn in a future version to inform about deprecation\n            const [x, y] = anchorPoint !== null && anchorPoint !== void 0 ? anchorPoint : AdvancedMarkerAnchorPoint['BOTTOM'];\n            // NOTE: since x and y can be any valid CSS length-percentage\n            //   value, we need to use calc() to negate them.\n            const translateX = `calc(-1 * ${x})`;\n            const translateY = `calc(-1 * ${y})`;\n            if (anchorOptionsSupported) {\n                // implement anchorPoint using the new anchorLeft and anchorTop options\n                marker.anchorLeft = translateX;\n                marker.anchorTop = translateY;\n                // reset transform from legacy implementation\n                contentElement.style.transform = '';\n            }\n            else {\n                // The \"translate(50%, 100%)\" counters and resets the default\n                // anchoring of the advanced marker element from the api\n                contentElement.style.transform = `translate(50%, 100%) translate(${translateX}, ${translateY})`;\n                // data-origin is needed to identify the custom marker content in the\n                // InfoWindow component as well as in the global CSS used to disable\n                // the pointer event when anchor points are used in older Google Maps\n                // versions.\n                marker.dataset.origin = 'rgm';\n                globalStyleManager.addAdvancedMarkerPointerEventsOverwrite();\n            }\n        }\n    }, [marker, anchorPoint, anchorLeft, anchorTop, hasChildren]);\n}\n\nfunction setValueForStyles(element, styles, prevStyles) {\n    if (styles != null && typeof styles !== 'object') {\n        throw new Error('The `style` prop expects a mapping from style properties to values, ' +\n            \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" +\n            'using JSX.');\n    }\n    const elementStyle = element.style;\n    // without `prevStyles`, just set all values\n    if (prevStyles == null) {\n        if (styles == null)\n            return;\n        for (const styleName in styles) {\n            if (!styles.hasOwnProperty(styleName))\n                continue;\n            setValueForStyle(elementStyle, styleName, styles[styleName]);\n        }\n        return;\n    }\n    // unset all styles in `prevStyles` that aren't in `styles`\n    for (const styleName in prevStyles) {\n        if (prevStyles.hasOwnProperty(styleName) &&\n            (styles == null || !styles.hasOwnProperty(styleName))) {\n            // Clear style\n            const isCustomProperty = styleName.indexOf('--') === 0;\n            if (isCustomProperty) {\n                elementStyle.setProperty(styleName, '');\n            }\n            else if (styleName === 'float') {\n                elementStyle.cssFloat = '';\n            }\n            else {\n                elementStyle[styleName] = '';\n            }\n        }\n    }\n    // only assign values from `styles` that are different from `prevStyles`\n    if (styles == null)\n        return;\n    for (const styleName in styles) {\n        const value = styles[styleName];\n        if (styles.hasOwnProperty(styleName) &&\n            prevStyles[styleName] !== value) {\n            setValueForStyle(elementStyle, styleName, value);\n        }\n    }\n}\nfunction setValueForStyle(elementStyle, styleName, value) {\n    const isCustomProperty = styleName.indexOf('--') === 0;\n    // falsy values will unset the style property\n    if (value == null || typeof value === 'boolean' || value === '') {\n        if (isCustomProperty) {\n            elementStyle.setProperty(styleName, '');\n        }\n        else if (styleName === 'float') {\n            elementStyle.cssFloat = '';\n        }\n        else {\n            elementStyle[styleName] = '';\n        }\n    }\n    // custom properties can't be directly assigned\n    else if (isCustomProperty) {\n        elementStyle.setProperty(styleName, value);\n    }\n    // numeric values are treated as 'px' unless the style property expects unitless numbers\n    else if (typeof value === 'number' &&\n        value !== 0 &&\n        !isUnitlessNumber(styleName)) {\n        elementStyle[styleName] = value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n    }\n    // everything else can just be assigned\n    else {\n        if (styleName === 'float') {\n            elementStyle.cssFloat = value;\n        }\n        else {\n            elementStyle[styleName] = ('' + value).trim();\n        }\n    }\n}\n// CSS properties which accept numbers but are not in units of \"px\".\nconst unitlessNumbers = new Set([\n    'animationIterationCount',\n    'aspectRatio',\n    'borderImageOutset',\n    'borderImageSlice',\n    'borderImageWidth',\n    'boxFlex',\n    'boxFlexGroup',\n    'boxOrdinalGroup',\n    'columnCount',\n    'columns',\n    'flex',\n    'flexGrow',\n    'flexPositive',\n    'flexShrink',\n    'flexNegative',\n    'flexOrder',\n    'gridArea',\n    'gridRow',\n    'gridRowEnd',\n    'gridRowSpan',\n    'gridRowStart',\n    'gridColumn',\n    'gridColumnEnd',\n    'gridColumnSpan',\n    'gridColumnStart',\n    'fontWeight',\n    'lineClamp',\n    'lineHeight',\n    'opacity',\n    'order',\n    'orphans',\n    'scale',\n    'tabSize',\n    'widows',\n    'zIndex',\n    'zoom',\n    'fillOpacity', // SVG-related properties\n    'floodOpacity',\n    'stopOpacity',\n    'strokeDasharray',\n    'strokeDashoffset',\n    'strokeMiterlimit',\n    'strokeOpacity',\n    'strokeWidth'\n]);\nfunction isUnitlessNumber(name) {\n    return unitlessNumbers.has(name);\n}\n\n/**\n * Component to render an Info Window with the Maps JavaScript API\n */\nconst InfoWindow = props => {\n    const { \n    // content options\n    children, headerContent, style, className, pixelOffset, \n    // open options\n    anchor, shouldFocus, \n    // events\n    onClose, onCloseClick } = props, \n    // other options\n    volatileInfoWindowOptions = __rest(props, [\"children\", \"headerContent\", \"style\", \"className\", \"pixelOffset\", \"anchor\", \"shouldFocus\", \"onClose\", \"onCloseClick\"]);\n    // ## create infowindow instance once the mapsLibrary is available.\n    const mapsLibrary = useMapsLibrary('maps');\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const contentContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const headerContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const infoWindowOptions = useMemoized(volatileInfoWindowOptions, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!mapsLibrary)\n            return;\n        contentContainerRef.current = document.createElement('div');\n        headerContainerRef.current = document.createElement('div');\n        const opts = infoWindowOptions;\n        if (pixelOffset) {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (headerContent) {\n            // if headerContent is specified as string we can directly forward it,\n            // otherwise we'll pass the element the portal will render into\n            opts.headerContent =\n                typeof headerContent === 'string'\n                    ? headerContent\n                    : headerContainerRef.current;\n        }\n        // intentionally shadowing the state variables here\n        const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n        infoWindow.setContent(contentContainerRef.current);\n        setInfoWindow(infoWindow);\n        // unmount: remove infoWindow and content elements (note: close is called in a different effect-cleanup)\n        return () => {\n            var _a, _b;\n            infoWindow.setContent(null);\n            (_a = contentContainerRef.current) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = headerContainerRef.current) === null || _b === void 0 ? void 0 : _b.remove();\n            contentContainerRef.current = null;\n            headerContainerRef.current = null;\n            setInfoWindow(null);\n        };\n    }, \n    // `infoWindowOptions` and other props are missing from dependencies:\n    //\n    // We don't want to re-create the infowindow instance\n    // when the options change.\n    // Updating the options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [mapsLibrary]);\n    // ---- update className and styles for `contentContainer`\n    // prevStyleRef stores previously applied style properties, so they can be\n    // removed when unset\n    const prevStyleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!infoWindow || !contentContainerRef.current)\n            return;\n        setValueForStyles(contentContainerRef.current, style || null, prevStyleRef.current);\n        prevStyleRef.current = style || null;\n        if (className !== contentContainerRef.current.className)\n            contentContainerRef.current.className = className || '';\n    }, [infoWindow, className, style]);\n    // ---- update options\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!infoWindow)\n            return;\n        const opts = infoWindowOptions;\n        if (!pixelOffset) {\n            opts.pixelOffset = null;\n        }\n        else {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (!headerContent) {\n            opts.headerContent = null;\n        }\n        else {\n            opts.headerContent =\n                typeof headerContent === 'string'\n                    ? headerContent\n                    : headerContainerRef.current;\n        }\n        infoWindow.setOptions(infoWindowOptions);\n    }, \n    // dependency `infoWindow` isn't needed since options are also passed\n    // to the constructor when a new infoWindow is created.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [infoWindowOptions, pixelOffset, headerContent]);\n    // ## bind event handlers\n    useMapsEventListener(infoWindow, 'close', onClose);\n    useMapsEventListener(infoWindow, 'closeclick', onCloseClick);\n    // ---- open info window when content and map are available\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        // `anchor === null` means an anchor is defined but not ready yet.\n        if (!map || !infoWindow || anchor === null)\n            return;\n        const isOpenedWithAnchor = !!anchor;\n        const openOptions = { map };\n        if (anchor) {\n            openOptions.anchor = anchor;\n            // Only do the infowindow adjusting when dealing with an AdvancedMarker\n            if (isAdvancedMarker(anchor) && anchor.content instanceof Element) {\n                const anchorBcr = anchor === null || anchor === void 0 ? void 0 : anchor.getBoundingClientRect();\n                // This checks whether or not the anchor has custom content with our own\n                // div wrapper. If not, that means we have a regular AdvancedMarker without\n                // children, or an AdvancedMarker that uses the anchorLeft/anchorTop props.\n                // In that case we do not want to adjust the infowindow since it is all handled correctly\n                // by the Google Maps API.\n                if (anchorBcr && anchor.dataset.origin === 'rgm') {\n                    // We can safely typecast here since we control that element and we know that\n                    // it is a div\n                    const anchorDomContent = (_a = anchor.content.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;\n                    const contentBcr = anchorDomContent === null || anchorDomContent === void 0 ? void 0 : anchorDomContent.getBoundingClientRect();\n                    // center infowindow above marker\n                    const anchorOffsetX = contentBcr.x -\n                        anchorBcr.x +\n                        (contentBcr.width - anchorBcr.width) / 2;\n                    const anchorOffsetY = contentBcr.y - anchorBcr.y;\n                    const opts = infoWindowOptions;\n                    opts.pixelOffset = new google.maps.Size(pixelOffset ? pixelOffset[0] + anchorOffsetX : anchorOffsetX, pixelOffset ? pixelOffset[1] + anchorOffsetY : anchorOffsetY);\n                    infoWindow.setOptions(opts);\n                }\n            }\n        }\n        if (shouldFocus !== undefined) {\n            openOptions.shouldFocus = shouldFocus;\n        }\n        infoWindow.open(openOptions);\n        return () => {\n            // Note: when the infowindow has an anchor, it will automatically show up again when the\n            // anchor was removed from the map before infoWindow.close() is called but the it gets\n            // added back to the map after that.\n            // More information here: https://issuetracker.google.com/issues/343750849\n            if (isOpenedWithAnchor)\n                infoWindow.set('anchor', null);\n            infoWindow.close();\n        };\n    }, [infoWindow, anchor, map, shouldFocus, infoWindowOptions, pixelOffset]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        contentContainerRef.current &&\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainerRef.current),\n        headerContainerRef.current !== null &&\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(headerContent, headerContainerRef.current)));\n};\n\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */\nfunction formatLocation(location) {\n    return typeof location === 'string'\n        ? location\n        : `${location.lat},${location.lng}`;\n}\n// Used for removing the leading pipe from the param string\nfunction formatParam(string) {\n    return string.slice(1);\n}\n\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */\nfunction assembleMarkerParams(markers = []) {\n    const markerParams = [];\n    // Group markers by style\n    const markersByStyle = markers === null || markers === void 0 ? void 0 : markers.reduce((styles, marker) => {\n        const { color = 'red', label, size, scale, icon, anchor } = marker;\n        // Create a unique style key based on either icon properties or standard marker properties\n        const relevantProps = icon ? [icon, anchor, scale] : [color, label, size];\n        const key = relevantProps.filter(Boolean).join('-');\n        styles[key] = styles[key] || [];\n        styles[key].push(marker);\n        return styles;\n    }, {});\n    Object.values(markersByStyle !== null && markersByStyle !== void 0 ? markersByStyle : {}).forEach(markers => {\n        let markerParam = '';\n        const { icon } = markers[0];\n        // Create marker style from first marker in group since all markers share the same style.\n        Object.entries(markers[0]).forEach(([key, value]) => {\n            // Determine which properties to include based on whether marker uses custom icon\n            const relevantKeys = icon\n                ? ['icon', 'anchor', 'scale']\n                : ['color', 'label', 'size'];\n            if (relevantKeys.includes(key)) {\n                markerParam += `|${key}:${value}`;\n            }\n        });\n        // Add location coordinates for each marker in the style group\n        // Handles both string locations and lat/lng object formats.\n        for (const marker of markers) {\n            const location = typeof marker.location === 'string'\n                ? marker.location\n                : `${marker.location.lat},${marker.location.lng}`;\n            markerParam += `|${location}`;\n        }\n        markerParams.push(markerParam);\n    });\n    return markerParams.map(formatParam);\n}\n\n// Style properties that can be applied to paths in the Static Maps API\nconst PATH_STYLE_KEYS = ['color', 'weight', 'fillcolor', 'geodesic'];\n/**\n * Builds the style portion of a path parameter string.\n * @param path - The path object containing style properties\n * @returns A string with style parameters in the format \"|key:value\"\n */\nfunction buildStyleParams(path) {\n    let styleParams = '';\n    PATH_STYLE_KEYS.forEach(key => {\n        if (path[key] !== undefined) {\n            styleParams += `|${key}:${path[key]}`;\n        }\n    });\n    return styleParams;\n}\n/**\n * Builds the coordinates portion of a path parameter string.\n * @param coordinates - Either a string or array of location objects\n * @returns A string with coordinates in the format \"|lat,lng|lat,lng\"\n */\nfunction buildCoordinateParams(coordinates) {\n    if (typeof coordinates === 'string') {\n        return `|${decodeURIComponent(coordinates)}`;\n    }\n    return coordinates.map(location => `|${formatLocation(location)}`).join('');\n}\n/**\n * Assembles path parameters for the Static Maps API from an array of paths.\n *\n * This function constructs a string of path parameters for each path. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * ```typescript\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * // Output: ['color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284']\n * ```\n */\nfunction assemblePathParams(paths = []) {\n    return paths.map(path => {\n        const styleParams = buildStyleParams(path);\n        const coordinateParams = buildCoordinateParams(path.coordinates);\n        const pathParam = styleParams + coordinateParams;\n        return formatParam(pathParam);\n    });\n}\n\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */\nfunction assembleMapTypeStyles(styles) {\n    return styles\n        .map((mapTypeStyle) => {\n        const { featureType, elementType, stylers = [] } = mapTypeStyle;\n        let styleString = '';\n        if (featureType) {\n            styleString += `|feature:${featureType}`;\n        }\n        if (elementType) {\n            styleString += `|element:${elementType}`;\n        }\n        for (const styler of stylers) {\n            Object.entries(styler).forEach(([name, value]) => {\n                styleString += `|${name}:${String(value).replace('#', '0x')}`;\n            });\n        }\n        return styleString;\n    })\n        .map(formatParam);\n}\n\nconst STATIC_MAPS_BASE = 'https://maps.googleapis.com/maps/api/staticmap';\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */\nfunction createStaticMapsUrl({ apiKey, width, height, center, zoom, scale, format, mapType, language, region, mapId, markers = [], paths = [], visible = [], style = [] }) {\n    if (!apiKey) {\n        console.warn('API key is required');\n    }\n    if (!width || !height) {\n        console.warn('Width and height are required');\n    }\n    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ key: apiKey, size: `${width}x${height}` }, (center && { center: formatLocation(center) })), (zoom && { zoom })), (scale && { scale })), (format && { format })), (mapType && { maptype: mapType })), (language && { language })), (region && { region })), (mapId && { map_id: mapId }));\n    const url = new URL(STATIC_MAPS_BASE);\n    // Params that don't need special handling\n    Object.entries(params).forEach(([key, value]) => {\n        url.searchParams.append(key, String(value));\n    });\n    // Assemble Markers\n    for (const markerParam of assembleMarkerParams(markers)) {\n        url.searchParams.append('markers', markerParam);\n    }\n    // Assemble Paths\n    for (const pathParam of assemblePathParams(paths)) {\n        url.searchParams.append('path', pathParam);\n    }\n    // Assemble visible locations\n    if (visible.length) {\n        url.searchParams.append('visible', visible.map(location => formatLocation(location)).join('|'));\n    }\n    // Assemble Map Type Styles\n    for (const styleString of assembleMapTypeStyles(style)) {\n        url.searchParams.append('style', styleString);\n    }\n    return url.toString();\n}\n\nconst StaticMap = (props) => {\n    const { url, className } = props;\n    if (!url)\n        throw new Error('URL is required');\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", { className: className, src: url, width: \"100%\" });\n};\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = ({ children, position }) => {\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map)\n            return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return () => {\n            const controlsArray = controls.getArray();\n            // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n            if (!controlsArray)\n                return;\n            const index = controlsArray.indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [controlContainer, map, position]);\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n\nfunction useMarker(props) {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = __rest(props, [\"onClick\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"onMouseOver\", \"onMouseOut\"]);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map) {\n            if (map === undefined)\n                console.error('<Marker> has to be inside a Map component.');\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return () => {\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n        // We do not want to re-render the whole marker when the options change.\n        // Marker options update is handled in a useEffect below.\n        // Excluding markerOptions from dependency array on purpose here.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [map]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick)\n            gme.addListener(m, 'click', onClick);\n        if (onDrag)\n            gme.addListener(m, 'drag', onDrag);\n        if (onDragStart)\n            gme.addListener(m, 'dragstart', onDragStart);\n        if (onDragEnd)\n            gme.addListener(m, 'dragend', onDragEnd);\n        if (onMouseOver)\n            gme.addListener(m, 'mouseover', onMouseOver);\n        if (onMouseOut)\n            gme.addListener(m, 'mouseout', onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return () => {\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        if (markerOptions)\n            marker.setOptions(markerOptions);\n    }, [marker, markerOptions]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        // Should not update position when draggable\n        if (draggable || !position || !marker)\n            return;\n        marker.setPosition(position);\n    }, [draggable, position, marker]);\n    return marker;\n}\n/**\n * Component to render a marker on a map\n */\nconst Marker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n});\nMarker.displayName = 'Marker';\nfunction useMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m) => {\n        setMarker(m);\n    }, []);\n    return [refCallback, marker];\n}\n\n/**\n * Component to configure the appearance of an AdvancedMarker\n */\nconst Pin = props => {\n    var _a;\n    const advancedMarker = (_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) === null || _a === void 0 ? void 0 : _a.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error('The <Pin> component can only be used inside <AdvancedMarker>.');\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce('The <Pin> component only uses children to render the glyph if both the glyph property and children are present.');\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce('Passing multiple children to the <Pin> component might lead to unexpected results.');\n        }\n        const pinViewOptions = Object.assign({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        // Here we are selecting the anchor container.\n        // The hierarchy is as follows:\n        // \"advancedMarker.content\" (from google) -> \"anchor container\"\n        const markerContent = (_a = advancedMarker.content) === null || _a === void 0 ? void 0 : _a.firstChild;\n        while (markerContent === null || markerContent === void 0 ? void 0 : markerContent.firstChild) {\n            markerContent.removeChild(markerContent.firstChild);\n        }\n        if (markerContent) {\n            markerContent.appendChild(pinElement.element);\n        }\n    }, [advancedMarker, glyphContainer, props]);\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n\nconst mapLinear = (x, a1, a2, b1, b2) => b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\nconst getMapMaxTilt = (zoom) => {\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the Google map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = ({ viewState }) => {\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return Object.assign(Object.assign({}, viewState), { fovy: 25, pitch: Math.min(maxTilt, pitch) });\n};\n\n\n//# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwcy9kaXN0L2luZGV4Lm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFLO0FBQzVIO0FBQ0M7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQU07QUFDdEIsSUFBSSxnREFBUztBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiOztBQUVBO0FBQ0EsaURBQWlELDRDQUFXO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQVU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNC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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVU7QUFDekI7QUFDQSxJQUFJLDBEQUFtQjtBQUN2QixXQUFXLGdEQUFtQixDQUFDLDJDQUFjO0FBQzdDLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0NBQWdDLCtDQUFRO0FBQ3hDLHdCQUF3QixrREFBVztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQVU7QUFDM0MsMkJBQTJCLDhDQUFPO0FBQ2xDO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBUTtBQUNwQjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyx1REFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsMkNBQTJDO0FBQ3BHOztBQUV3ZDtBQUN4ZCIsInNvdXJjZXMiOlsiL1VzZXJzL2ltYWFkL2kvZ2xvYmFsL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0LCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgaXNEZWVwRXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcblxuLy8gVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSB0aGUgYnVpbGQgcHJvY2Vzcy5cbmNvbnN0IFZFUlNJT04gPSAnMS43LjEnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmNvbnN0IEFQSUxvYWRpbmdTdGF0dXMgPSB7XG4gICAgTk9UX0xPQURFRDogJ05PVF9MT0FERUQnLFxuICAgIExPQURJTkc6ICdMT0FESU5HJyxcbiAgICBMT0FERUQ6ICdMT0FERUQnLFxuICAgIEZBSUxFRDogJ0ZBSUxFRCcsXG4gICAgQVVUSF9GQUlMVVJFOiAnQVVUSF9GQUlMVVJFJ1xufTtcblxuY29uc3QgTUFQU19BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbi8qKlxuICogQSBHb29nbGVNYXBzQXBpTG9hZGVyIHRvIHJlbGlhYmx5IGxvYWQgYW5kIHVubG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkuXG4gKlxuICogVGhlIGFjdHVhbCBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgaXMgZGVsYXllZCBpbnRvIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHRvXG4gKiBhbGxvdyB1c2luZyB0aGUgQVBJIGluIGFuIHVzZUVmZmVjdCBob29rLCB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IG11bHRpcGxlIEFQSSBsb2Fkcy5cbiAqL1xuY2xhc3MgR29vZ2xlTWFwc0FwaUxvYWRlciB7XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIE1hcHMgSmF2YVNjcmlwdCBBUEkgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAgICogU2luY2UgdGhlIE1hcHMgbGlicmFyeSBjYW4gb25seSBiZSBsb2FkZWQgb25jZSBwZXIgcGFnZSwgdGhpcyB3aWxsXG4gICAgICogcHJvZHVjZSBhIHdhcm5pbmcgd2hlbiBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnRcbiAgICAgKiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIGNvbXBsZXRlc1xuICAgICAqIGFuZCByZWplY3RzIGluIGNhc2Ugb2YgYW4gZXJyb3Igb3Igd2hlbiB0aGUgbG9hZGluZyB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9hZChwYXJhbXMsIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcmllcyA9IHBhcmFtcy5saWJyYXJpZXMgPyBwYXJhbXMubGlicmFyaWVzLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB0aGlzLnNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gTm90ZTogaWYgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGhhcyBiZWVuIGRlZmluZWQgZXh0ZXJuYWxseSwgd2VcbiAgICAgICAgICAgIC8vICAgYXNzdW1lIHRoYXQgbG9hZGluZyBpcyBjb21wbGV0ZSBhbmQgc3VjY2Vzc2Z1bC5cbiAgICAgICAgICAgIC8vICAgSWYgaXQgd2FzIGRlZmluZWQgYnkgYSBwcmV2aW91cyBjYWxsIHRvIHRoaXMgbWV0aG9kLCBhIHdhcm5pbmdcbiAgICAgICAgICAgIC8vICAgbWVzc2FnZSBpcyBsb2dnZWQgaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGluIGFwaS1wYXJhbWV0ZXJzIHVzZWRcbiAgICAgICAgICAgIC8vICAgZm9yIGJvdGggY2FsbHMuXG4gICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gd2luZG93Lmdvb2dsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbXBvcnRMaWJyYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gc2VyaWFsaXplZCBwYXJhbWV0ZXJzIG1lYW5zIGl0IHdhcyBsb2FkZWQgZXh0ZXJuYWxseVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyA9IHNlcmlhbGl6ZWRQYXJhbXM7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0SW1wb3J0TGlicmFyeShwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAhPT0gc2VyaWFsaXplZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXJdIFRoZSBtYXBzIEFQSSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnMgYW5kIHdpbGwgbm90IGJlIGxvYWRlZCBhZ2Fpbi4gUmVmcmVzaCB0aGUgYCArXG4gICAgICAgICAgICAgICAgICAgIGBwYWdlIGZvciBuZXcgdmFsdWVzIHRvIGhhdmUgZWZmZWN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlicmFyaWVzVG9Mb2FkID0gWydtYXBzJywgLi4ubGlicmFyaWVzXTtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGxpYnJhcmllc1RvTG9hZC5tYXAobmFtZSA9PiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KG5hbWUpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBlYXNpZXIgY29tcGFyaXNvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VyaWFsaXplUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcGFyYW1zLnYsXG4gICAgICAgICAgICBwYXJhbXMua2V5LFxuICAgICAgICAgICAgcGFyYW1zLmxhbmd1YWdlLFxuICAgICAgICAgICAgcGFyYW1zLnJlZ2lvbixcbiAgICAgICAgICAgIHBhcmFtcy5hdXRoUmVmZXJyZXJQb2xpY3ksXG4gICAgICAgICAgICBwYXJhbXMuc29sdXRpb25DaGFubmVsXG4gICAgICAgIF0uam9pbignLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBnbG9iYWwgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGZ1bmN0aW9uIGZvciBib290c3RyYXBwaW5nLlxuICAgICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZHluYW1pYyBsb2FkaW5nIHNjcmlwdFxuICAgICAqIGZyb20gdGhlIG9mZmljaWFsIGRvY3VtZW50YXRpb24gd2l0aCBzb21lIG1pbm9yIGFkanVzdG1lbnRzLlxuICAgICAqXG4gICAgICogVGhlIGNyZWF0ZWQgaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB3aWxsIGxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLFxuICAgICAqIHdoaWNoIHdpbGwgdGhlbiByZXBsYWNlIHRoZSBgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeWAgZnVuY3Rpb24gd2l0aCB0aGUgZnVsbFxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9sb2FkLW1hcHMtanMtYXBpI2R5bmFtaWMtbGlicmFyeS1pbXBvcnRcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKSB7XG4gICAgICAgIGlmICghd2luZG93Lmdvb2dsZSlcbiAgICAgICAgICAgIHdpbmRvdy5nb29nbGUgPSB7fTtcbiAgICAgICAgaWYgKCF3aW5kb3cuZ29vZ2xlLm1hcHMpXG4gICAgICAgICAgICB3aW5kb3cuZ29vZ2xlLm1hcHMgPSB7fTtcbiAgICAgICAgaWYgKHdpbmRvdy5nb29nbGUubWFwc1snaW1wb3J0TGlicmFyeSddKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZ29vZ2xlLW1hcHMtYXBpLWxvYWRlci1pbnRlcm5hbF06IGluaXRJbXBvcnRMaWJyYXJ5IG11c3Qgb25seSBiZSBjYWxsZWQgb25jZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcGlQcm9taXNlID0gbnVsbDtcbiAgICAgICAgY29uc3QgbG9hZEFwaSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChhcGlQcm9taXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgICAgICAgICAgYXBpUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybFBhcmFtTmFtZSA9IGtleS5yZXBsYWNlKC9bQS1aXS9nLCB0ID0+ICdfJyArIHRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQodXJsUGFyYW1OYW1lLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zLnNldCgnbG9hZGluZycsICdhc3luYycpO1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQoJ2NhbGxiYWNrJywgJ19fZ29vZ2xlTWFwc0NhbGxiYWNrX18nKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbGVtZW50LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbGVtZW50LnNyYyA9IE1BUFNfQVBJX0JBU0VfVVJMICsgYD9gICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5ub25jZSA9XG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub25jZSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBjb3VsZCBub3QgbG9hZC4nKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19nb29nbGVNYXBzQ2FsbGJhY2tfXyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5MT0FERUQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZ21fYXV0aEZhaWx1cmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BRElORztcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZChzY3JpcHRFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFwaVByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciB0aGUgZmlyc3QgbG9hZCwgd2UgZGVjbGFyZSBhbiBpbXBvcnRMaWJyYXJ5IGZ1bmN0aW9uIHRoYXQgd2lsbFxuICAgICAgICAvLyBiZSBvdmVyd3JpdHRlbiBvbmNlIHRoZSBhcGkgaXMgbG9hZGVkLlxuICAgICAgICBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5ID0gbGlicmFyeU5hbWUgPT4gbG9hZEFwaSgpLnRoZW4oKCkgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShsaWJyYXJ5TmFtZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBhbGwgcmVnaXN0ZXJlZCBsb2FkaW5nU3RhdHVzTGlzdGVuZXJzIGFmdGVyIGEgc3RhdHVzIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgZm4odGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIGN1cnJlbnQgbG9hZGluZ1N0YXR1cyBvZiB0aGUgQVBJLlxuICovXG5Hb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG4vKipcbiAqIEEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgbG9hZGluZyBzdGF0dXMgY2hhbmdlcy5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5saXN0ZW5lcnMgPSBbXTtcblxuY29uc3QgREVGQVVMVF9TT0xVVElPTl9DSEFOTkVMID0gJ0dNUF92aXNnbF9yZ21saWJyYXJ5X3YxX2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVF9JTlRFUk5BTF9VU0FHRV9BVFRSSUJVVElPTl9JRFMgPSBbXG4gICAgYGdtcF92aXNnbF9yZWFjdGdvb2dsZW1hcHNfdiR7VkVSU0lPTn1gXG5dO1xuY29uc3QgQVBJUHJvdmlkZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogbG9jYWwgaG9vayB0byBzZXQgdXAgdGhlIG1hcC1pbnN0YW5jZSBtYW5hZ2VtZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlcygpIHtcbiAgICBjb25zdCBbbWFwSW5zdGFuY2VzLCBzZXRNYXBJbnN0YW5jZXNdID0gdXNlU3RhdGUoe30pO1xuICAgIGNvbnN0IGFkZE1hcEluc3RhbmNlID0gKG1hcEluc3RhbmNlLCBpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgICAgICBzZXRNYXBJbnN0YW5jZXMoaW5zdGFuY2VzID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlcyksIHsgW2lkXTogbWFwSW5zdGFuY2UgfSkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZU1hcEluc3RhbmNlID0gKGlkID0gJ2RlZmF1bHQnKSA9PiB7XG4gICAgICAgIHNldE1hcEluc3RhbmNlcygoX2EpID0+IHtcbiAgICAgICAgICAgIHZhciBfYiA9IGlkOyBfYVtfYl07IHZhciByZW1haW5pbmcgPSBfX3Jlc3QoX2EsIFt0eXBlb2YgX2IgPT09IFwic3ltYm9sXCIgPyBfYiA6IF9iICsgXCJcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhck1hcEluc3RhbmNlcyA9ICgpID0+IHtcbiAgICAgICAgc2V0TWFwSW5zdGFuY2VzKHt9KTtcbiAgICB9O1xuICAgIHJldHVybiB7IG1hcEluc3RhbmNlcywgYWRkTWFwSW5zdGFuY2UsIHJlbW92ZU1hcEluc3RhbmNlLCBjbGVhck1hcEluc3RhbmNlcyB9O1xufVxuLyoqXG4gKiBsb2NhbCBob29rIHRvIGhhbmRsZSB0aGUgbG9hZGluZyBvZiB0aGUgbWFwcyBBUEksIHJldHVybnMgdGhlIGN1cnJlbnQgbG9hZGluZyBzdGF0dXNcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5mdW5jdGlvbiB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBvbkxvYWQsIG9uRXJyb3IsIGFwaUtleSwgdmVyc2lvbiwgbGlicmFyaWVzID0gW10gfSA9IHByb3BzLCBvdGhlckFwaVBhcmFtcyA9IF9fcmVzdChwcm9wcywgW1wib25Mb2FkXCIsIFwib25FcnJvclwiLCBcImFwaUtleVwiLCBcInZlcnNpb25cIiwgXCJsaWJyYXJpZXNcIl0pO1xuICAgIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShHb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMpO1xuICAgIGNvbnN0IFtsb2FkZWRMaWJyYXJpZXMsIGFkZExvYWRlZExpYnJhcnldID0gdXNlUmVkdWNlcigobG9hZGVkTGlicmFyaWVzLCBhY3Rpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1thY3Rpb24ubmFtZV1cbiAgICAgICAgICAgID8gbG9hZGVkTGlicmFyaWVzXG4gICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9hZGVkTGlicmFyaWVzKSwgeyBbYWN0aW9uLm5hbWVdOiBhY3Rpb24udmFsdWUgfSk7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGxpYnJhcmllc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gbGlicmFyaWVzID09PSBudWxsIHx8IGxpYnJhcmllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlicmFyaWVzLmpvaW4oJywnKSwgW2xpYnJhcmllc10pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB1c2VNZW1vKCgpID0+IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBhcGlLZXksIHZlcnNpb24gfSwgb3RoZXJBcGlQYXJhbXMpKSwgW2FwaUtleSwgdmVyc2lvbiwgb3RoZXJBcGlQYXJhbXNdKTtcbiAgICBjb25zdCBpbXBvcnRMaWJyYXJ5ID0gdXNlQ2FsbGJhY2soKG5hbWUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobG9hZGVkTGlicmFyaWVzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkTGlicmFyaWVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChfYSA9IGdvb2dsZSA9PT0gbnVsbCB8fCBnb29nbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdvb2dsZS5tYXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW1wb3J0TGlicmFyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2FwaS1wcm92aWRlci1pbnRlcm5hbF0gaW1wb3J0TGlicmFyeSB3YXMgY2FsbGVkIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAnZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSB3YXMgZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB3aW5kb3cuZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICAgICAgYWRkTG9hZGVkTGlicmFyeSh7IG5hbWUsIHZhbHVlOiByZXMgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSksIFtsb2FkZWRMaWJyYXJpZXNdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHsga2V5OiBhcGlLZXkgfSwgb3RoZXJBcGlQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgaWYgKChsaWJyYXJpZXNTdHJpbmcgPT09IG51bGwgfHwgbGlicmFyaWVzU3RyaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaWJyYXJpZXNTdHJpbmcubGVuZ3RoKSA+IDApXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5saWJyYXJpZXMgPSBsaWJyYXJpZXNTdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jaGFubmVsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNoYW5uZWwgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jaGFubmVsID4gOTk5KVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zb2x1dGlvbkNoYW5uZWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNvbHV0aW9uQ2hhbm5lbCA9IERFRkFVTFRfU09MVVRJT05fQ0hBTk5FTDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuc29sdXRpb25DaGFubmVsID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWw7XG4gICAgICAgICAgICAgICAgeWllbGQgR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkKHBhcmFtcywgc3RhdHVzID0+IHNldFN0YXR1cyhzdGF0dXMpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgWydjb3JlJywgJ21hcHMnLCAuLi5saWJyYXJpZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc8QXBpUHJvdmlkZXI+IGZhaWxlZCB0byBsb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSScsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSgpO1xuICAgIH0sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbYXBpS2V5LCBsaWJyYXJpZXNTdHJpbmcsIHNlcmlhbGl6ZWRQYXJhbXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMocHJvcHMpIHtcbiAgICBjb25zdCBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSB1c2VNZW1vKCgpID0+IHByb3BzLmRpc2FibGVVc2FnZUF0dHJpYnV0aW9uXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IERFRkFVTFRfSU5URVJOQUxfVVNBR0VfQVRUUklCVVRJT05fSURTLCBbcHJvcHMuZGlzYWJsZVVzYWdlQXR0cmlidXRpb25dKTtcbiAgICByZXR1cm4gaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gd3JhcCB0aGUgY29tcG9uZW50cyBmcm9tIHRoaXMgbGlicmFyeSBhbmQgbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUElcbiAqL1xuY29uc3QgQVBJUHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHMsIGxvYWRlclByb3BzID0gX19yZXN0KHByb3BzLCBbXCJjaGlsZHJlblwiXSk7XG4gICAgY29uc3QgeyBtYXBJbnN0YW5jZXMsIGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSwgY2xlYXJNYXBJbnN0YW5jZXMgfSA9IHVzZU1hcEluc3RhbmNlcygpO1xuICAgIGNvbnN0IHsgc3RhdHVzLCBsb2FkZWRMaWJyYXJpZXMsIGltcG9ydExpYnJhcnkgfSA9IHVzZUdvb2dsZU1hcHNBcGlMb2FkZXIobG9hZGVyUHJvcHMpO1xuICAgIGNvbnN0IGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyA9IHVzZUludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyhsb2FkZXJQcm9wcyk7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBtYXBJbnN0YW5jZXMsXG4gICAgICAgIGFkZE1hcEluc3RhbmNlLFxuICAgICAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICAgICAgY2xlYXJNYXBJbnN0YW5jZXMsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9hZGVkTGlicmFyaWVzLFxuICAgICAgICBpbXBvcnRMaWJyYXJ5LFxuICAgICAgICBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICB9KSwgW1xuICAgICAgICBtYXBJbnN0YW5jZXMsXG4gICAgICAgIGFkZE1hcEluc3RhbmNlLFxuICAgICAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICAgICAgY2xlYXJNYXBJbnN0YW5jZXMsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9hZGVkTGlicmFyaWVzLFxuICAgICAgICBpbXBvcnRMaWJyYXJ5LFxuICAgICAgICBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQVBJUHJvdmlkZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCBlZmZlY3RzIHRvIGJpbmQgZXZlbnQtaGFuZGxlcnMgZm9yIGFsbCBldmVudC1wcm9wcyBpbiBNYXBFdmVudFByb3BzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEV2ZW50cyhtYXAsIHByb3BzKSB7XG4gICAgLy8gbm90ZTogY2FsbGluZyBhIHVzZUVmZmVjdCBob29rIGZyb20gd2l0aGluIGEgbG9vcCBpcyBwcm9oaWJpdGVkIGJ5IHRoZVxuICAgIC8vIHJ1bGVzIG9mIGhvb2tzLCBidXQgaXQncyBvayBoZXJlIHNpbmNlIGl0J3MgdW5jb25kaXRpb25hbCBhbmQgdGhlIG51bWJlclxuICAgIC8vIGFuZCBvcmRlciBvZiBpdGVyYXRpb25zIGlzIGFsd2F5cyBzdHJpY3RseSB0aGUgc2FtZS5cbiAgICAvLyAoc2VlIGh0dHBzOi8vbGVnYWN5LnJlYWN0anMub3JnL2RvY3MvaG9va3MtcnVsZXMuaHRtbClcbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIGV2ZW50UHJvcE5hbWVzKSB7XG4gICAgICAgIC8vIGZpeG1lOiB0aGlzIGNhc3QgaXMgZXNzZW50aWFsbHkgYSAndHJ1c3QgbWUsIGJybycgZm9yIHR5cGVzY3JpcHQsIGJ1dFxuICAgICAgICAvLyAgIGEgcHJvcGVyIHNvbHV0aW9uIHNlZW1zIHdheSB0b28gY29tcGxpY2F0ZWQgcmlnaHQgbm93XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IHByb3BOYW1lVG9FdmVudFR5cGVbcHJvcE5hbWVdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgZXZlbnRUeXBlLCAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGNyZWF0ZU1hcEV2ZW50KGV2ZW50VHlwZSwgbWFwLCBldikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIH0sIFttYXAsIGV2ZW50VHlwZSwgaGFuZGxlcl0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIHRoZSB3cmFwcGVkIG1hcC1ldmVudHMgdXNlZCBmb3IgdGhlIGV2ZW50LXByb3BzLlxuICogQHBhcmFtIHR5cGUgdGhlIGV2ZW50IHR5cGUgYXMgaXQgaXMgc3BlY2lmaWVkIHRvIHRoZSBtYXBzIGFwaVxuICogQHBhcmFtIG1hcCB0aGUgbWFwIGluc3RhbmNlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb21cbiAqIEBwYXJhbSBzcmNFdmVudCB0aGUgc291cmNlLWV2ZW50IGlmIHRoZXJlIGlzIG9uZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFwRXZlbnQodHlwZSwgbWFwLCBzcmNFdmVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBldiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbWFwLFxuICAgICAgICBkZXRhaWw6IHt9LFxuICAgICAgICBzdG9wcGFibGU6IGZhbHNlLFxuICAgICAgICBzdG9wOiAoKSA9PiB7IH1cbiAgICB9O1xuICAgIGlmIChjYW1lcmFFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGNhbUV2ZW50ID0gZXY7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gICAgICAgIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVFdmVudF0gYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbWFwICcgK1xuICAgICAgICAgICAgICAgICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgK1xuICAgICAgICAgICAgICAgICdyZXBvcnQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2dsL3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy9uZXcnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW1FdmVudC5kZXRhaWwgPSB7XG4gICAgICAgICAgICBjZW50ZXI6IChjZW50ZXIgPT09IG51bGwgfHwgY2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXIudG9KU09OKCkpIHx8IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgICAgIHpvb206IHpvb20gfHwgMCxcbiAgICAgICAgICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgICAgICAgICB0aWx0OiB0aWx0LFxuICAgICAgICAgICAgYm91bmRzOiAoYm91bmRzID09PSBudWxsIHx8IGJvdW5kcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm91bmRzLnRvSlNPTigpKSB8fCB7XG4gICAgICAgICAgICAgICAgbm9ydGg6IDkwLFxuICAgICAgICAgICAgICAgIGVhc3Q6IDE4MCxcbiAgICAgICAgICAgICAgICBzb3V0aDogLTkwLFxuICAgICAgICAgICAgICAgIHdlc3Q6IC0xODBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbUV2ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChtb3VzZUV2ZW50VHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgaWYgKCFzcmNFdmVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2NyZWF0ZUV2ZW50XSBtb3VzZSBldmVudHMgbXVzdCBwcm92aWRlIGEgc3JjRXZlbnQnKTtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IGV2O1xuICAgICAgICBtb3VzZUV2ZW50LmRvbUV2ZW50ID0gc3JjRXZlbnQuZG9tRXZlbnQ7XG4gICAgICAgIG1vdXNlRXZlbnQuc3RvcHBhYmxlID0gdHJ1ZTtcbiAgICAgICAgbW91c2VFdmVudC5zdG9wID0gKCkgPT4gc3JjRXZlbnQuc3RvcCgpO1xuICAgICAgICBtb3VzZUV2ZW50LmRldGFpbCA9IHtcbiAgICAgICAgICAgIGxhdExuZzogKChfYSA9IHNyY0V2ZW50LmxhdExuZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpKSB8fCBudWxsLFxuICAgICAgICAgICAgcGxhY2VJZDogc3JjRXZlbnQucGxhY2VJZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW91c2VFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGV2O1xufVxuLyoqXG4gKiBtYXBzIHRoZSBjYW1lbENhc2VkIG5hbWVzIG9mIGV2ZW50LXByb3BzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LXR5cGVzXG4gKiB1c2VkIGluIHRoZSBtYXBzIEFQSS5cbiAqL1xuY29uc3QgcHJvcE5hbWVUb0V2ZW50VHlwZSA9IHtcbiAgICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gICAgb25DZW50ZXJDaGFuZ2VkOiAnY2VudGVyX2NoYW5nZWQnLFxuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25Db250ZXh0bWVudTogJ2NvbnRleHRtZW51JyxcbiAgICBvbkRibGNsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ2VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ3N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbkhlYWRpbmdDaGFuZ2VkOiAnaGVhZGluZ19jaGFuZ2VkJyxcbiAgICBvbklkbGU6ICdpZGxlJyxcbiAgICBvbklzRnJhY3Rpb25hbFpvb21FbmFibGVkQ2hhbmdlZDogJ2lzZnJhY3Rpb25hbHpvb21lbmFibGVkX2NoYW5nZWQnLFxuICAgIG9uTWFwQ2FwYWJpbGl0aWVzQ2hhbmdlZDogJ21hcGNhcGFiaWxpdGllc19jaGFuZ2VkJyxcbiAgICBvbk1hcFR5cGVJZENoYW5nZWQ6ICdtYXB0eXBlaWRfY2hhbmdlZCcsXG4gICAgb25Nb3VzZW1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VvdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZW92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uUHJvamVjdGlvbkNoYW5nZWQ6ICdwcm9qZWN0aW9uX2NoYW5nZWQnLFxuICAgIG9uUmVuZGVyaW5nVHlwZUNoYW5nZWQ6ICdyZW5kZXJpbmd0eXBlX2NoYW5nZWQnLFxuICAgIG9uVGlsZXNMb2FkZWQ6ICd0aWxlc2xvYWRlZCcsXG4gICAgb25UaWx0Q2hhbmdlZDogJ3RpbHRfY2hhbmdlZCcsXG4gICAgb25ab29tQ2hhbmdlZDogJ3pvb21fY2hhbmdlZCcsXG4gICAgLy8gbm90ZTogb25DYW1lcmFDaGFuZ2VkIGlzIGFuIGFsaWFzIGZvciB0aGUgYm91bmRzX2NoYW5nZWQgZXZlbnQsXG4gICAgLy8gc2luY2UgdGhhdCBpcyBnb2luZyB0byBiZSBmaXJlZCBpbiBldmVyeSBzaXR1YXRpb24gd2hlcmUgdGhlIGNhbWVyYSBpc1xuICAgIC8vIHVwZGF0ZWQuXG4gICAgb25DYW1lcmFDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnXG59O1xuY29uc3QgY2FtZXJhRXZlbnRUeXBlcyA9IFtcbiAgICAnYm91bmRzX2NoYW5nZWQnLFxuICAgICdjZW50ZXJfY2hhbmdlZCcsXG4gICAgJ2hlYWRpbmdfY2hhbmdlZCcsXG4gICAgJ3RpbHRfY2hhbmdlZCcsXG4gICAgJ3pvb21fY2hhbmdlZCdcbl07XG5jb25zdCBtb3VzZUV2ZW50VHlwZXMgPSBbXG4gICAgJ2NsaWNrJyxcbiAgICAnY29udGV4dG1lbnUnLFxuICAgICdkYmxjbGljaycsXG4gICAgJ21vdXNlbW92ZScsXG4gICAgJ21vdXNlb3V0JyxcbiAgICAnbW91c2VvdmVyJ1xuXTtcbmNvbnN0IGV2ZW50UHJvcE5hbWVzID0gT2JqZWN0LmtleXMocHJvcE5hbWVUb0V2ZW50VHlwZSk7XG5cbi8qKlxuICogQSBob29rIHRvIHN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhIHZhcmlhYmxlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzdG9yZVxuICogQHJldHVybnMgVGhlIHByZXZpb3VzIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcmVmc1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gdXNlTWVtb2l6ZWQodmFsdWUsIGlzRXF1YWwpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IHVzZVByZXZpb3VzKHZhbHVlKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91cyAmJiBpc0VxdWFsKHByZXZpb3VzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgW3ZhbHVlLCBwcmV2aW91cywgaXNFcXVhbF0pO1xufVxuXG5mdW5jdGlvbiB1c2VDdXN0b21Db21wYXJlRWZmZWN0KGVmZmVjdCwgZGVwZW5kZW5jaWVzLCBpc0VxdWFsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHVzZUVmZmVjdChlZmZlY3QsIFt1c2VNZW1vaXplZChkZXBlbmRlbmNpZXMsIGlzRXF1YWwpXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZXBDb21wYXJlRWZmZWN0KGVmZmVjdCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgdXNlQ3VzdG9tQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcywgaXNEZWVwRXF1YWwpO1xufVxuXG5jb25zdCBtYXBPcHRpb25LZXlzID0gbmV3IFNldChbXG4gICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgJ2NsaWNrYWJsZUljb25zJyxcbiAgICAnY29udHJvbFNpemUnLFxuICAgICdkaXNhYmxlRGVmYXVsdFVJJyxcbiAgICAnZGlzYWJsZURvdWJsZUNsaWNrWm9vbScsXG4gICAgJ2RyYWdnYWJsZScsXG4gICAgJ2RyYWdnYWJsZUN1cnNvcicsXG4gICAgJ2RyYWdnaW5nQ3Vyc29yJyxcbiAgICAnZnVsbHNjcmVlbkNvbnRyb2wnLFxuICAgICdmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnMnLFxuICAgICdnZXN0dXJlSGFuZGxpbmcnLFxuICAgICdoZWFkaW5nSW50ZXJhY3Rpb25FbmFibGVkJyxcbiAgICAnaXNGcmFjdGlvbmFsWm9vbUVuYWJsZWQnLFxuICAgICdrZXlib2FyZFNob3J0Y3V0cycsXG4gICAgJ21hcFR5cGVDb250cm9sJyxcbiAgICAnbWFwVHlwZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnbWFwVHlwZUlkJyxcbiAgICAnbWF4Wm9vbScsXG4gICAgJ21pblpvb20nLFxuICAgICdub0NsZWFyJyxcbiAgICAncGFuQ29udHJvbCcsXG4gICAgJ3BhbkNvbnRyb2xPcHRpb25zJyxcbiAgICAncmVzdHJpY3Rpb24nLFxuICAgICdyb3RhdGVDb250cm9sJyxcbiAgICAncm90YXRlQ29udHJvbE9wdGlvbnMnLFxuICAgICdzY2FsZUNvbnRyb2wnLFxuICAgICdzY2FsZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnc2Nyb2xsd2hlZWwnLFxuICAgICdzdHJlZXRWaWV3JyxcbiAgICAnc3RyZWV0Vmlld0NvbnRyb2wnLFxuICAgICdzdHJlZXRWaWV3Q29udHJvbE9wdGlvbnMnLFxuICAgICdzdHlsZXMnLFxuICAgICd0aWx0SW50ZXJhY3Rpb25FbmFibGVkJyxcbiAgICAnem9vbUNvbnRyb2wnLFxuICAgICd6b29tQ29udHJvbE9wdGlvbnMnXG5dKTtcbi8qKlxuICogSW50ZXJuYWwgaG9vayB0byB1cGRhdGUgdGhlIG1hcC1vcHRpb25zIHdoZW4gcHJvcHMgYXJlIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIG1hcCB0aGUgbWFwIGluc3RhbmNlXG4gKiBAcGFyYW0gbWFwUHJvcHMgdGhlIHByb3BzIHRvIHVwZGF0ZSB0aGUgbWFwLWluc3RhbmNlIHdpdGhcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBPcHRpb25zKG1hcCwgbWFwUHJvcHMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS1cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZWZmZWN0cyBhcmVuJ3QgdHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBpcyBjaGFuZ2VkLlxuICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIHZhbHVlcyB3aWxsIGJlIG9yIGhhdmUgYmVlbiBwYXNzZWQgdG8gdGhlIG1hcFxuICAgICAqIGNvbnN0cnVjdG9yIHZpYSBtYXBPcHRpb25zLlxuICAgICAqL1xuICAgIGNvbnN0IG1hcE9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobWFwUHJvcHMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFtYXBPcHRpb25LZXlzLmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIG1hcE9wdGlvbnNba2V5XSA9IG1hcFByb3BzW2tleV07XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0aGUgbWFwIG9wdGlvbnMgd2hlbiBtYXBPcHRpb25zIGlzIGNoYW5nZWRcbiAgICAvLyBOb3RlOiBkdWUgdG8gdGhlIGRlc3RydWN0dXJpbmcgYWJvdmUsIG1hcE9wdGlvbnMgd2lsbCBiZSBzZWVuIGFzIGNoYW5nZWRcbiAgICAvLyAgIHdpdGggZXZlcnkgcmUtcmVuZGVyLCBzbyB3ZSdyZSBhc3N1bWluZyB0aGUgbWFwcy1hcGkgd2lsbCBwcm9wZXJseVxuICAgIC8vICAgZGVhbCB3aXRoIHVuY2hhbmdlZCBvcHRpb24tdmFsdWVzIHBhc3NlZCBpbnRvIHNldE9wdGlvbnMuXG4gICAgdXNlRGVlcENvbXBhcmVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFwLnNldE9wdGlvbnMobWFwT3B0aW9ucyk7XG4gICAgfSwgW21hcE9wdGlvbnNdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xufVxuXG5mdW5jdGlvbiB1c2VBcGlMb2FkaW5nU3RhdHVzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgfHwgQVBJTG9hZGluZ1N0YXR1cy5OT1RfTE9BREVEO1xufVxuXG4vKipcbiAqIEludGVybmFsIGhvb2sgdGhhdCB1cGRhdGVzIHRoZSBjYW1lcmEgd2hlbiBkZWNrLmdsIHZpZXdTdGF0ZSBjaGFuZ2VzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURlY2tHTENhbWVyYVVwZGF0ZShtYXAsIHByb3BzKSB7XG4gICAgY29uc3QgeyB2aWV3cG9ydCwgdmlld1N0YXRlIH0gPSBwcm9wcztcbiAgICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSAhIXZpZXdwb3J0O1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICF2aWV3U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYmVhcmluZzogaGVhZGluZywgcGl0Y2g6IHRpbHQsIHpvb20gfSA9IHZpZXdTdGF0ZTtcbiAgICAgICAgbWFwLm1vdmVDYW1lcmEoe1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICBoZWFkaW5nLFxuICAgICAgICAgICAgdGlsdCxcbiAgICAgICAgICAgIHpvb206IHpvb20gKyAxXG4gICAgICAgIH0pO1xuICAgIH0sIFttYXAsIHZpZXdTdGF0ZV0pO1xuICAgIHJldHVybiBpc0RlY2tHbENvbnRyb2xsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKCdsYXQnIGluIG9iaiAmJiAnbG5nJyBpbiBvYmopKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShvYmoubGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUob2JqLmxuZyk7XG59XG5mdW5jdGlvbiBsYXRMbmdFcXVhbHMoYSwgYikge1xuICAgIGlmICghYSB8fCAhYilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IEEgPSB0b0xhdExuZ0xpdGVyYWwoYSk7XG4gICAgY29uc3QgQiA9IHRvTGF0TG5nTGl0ZXJhbChiKTtcbiAgICBpZiAoQS5sYXQgIT09IEIubGF0IHx8IEEubG5nICE9PSBCLmxuZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9MYXRMbmdMaXRlcmFsKG9iaikge1xuICAgIGlmIChpc0xhdExuZ0xpdGVyYWwob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xufVxuXG5mdW5jdGlvbiB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgbWFwUHJvcHMpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBtYXBQcm9wcy5jZW50ZXIgPyB0b0xhdExuZ0xpdGVyYWwobWFwUHJvcHMuY2VudGVyKSA6IG51bGw7XG4gICAgbGV0IGxhdCA9IG51bGw7XG4gICAgbGV0IGxuZyA9IG51bGw7XG4gICAgaWYgKGNlbnRlciAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sbmcpKSB7XG4gICAgICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgICAgIGxuZyA9IGNlbnRlci5sbmc7XG4gICAgfVxuICAgIGNvbnN0IHpvb20gPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMuem9vbSlcbiAgICAgICAgPyBtYXBQcm9wcy56b29tXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBoZWFkaW5nID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLmhlYWRpbmcpXG4gICAgICAgID8gbWFwUHJvcHMuaGVhZGluZ1xuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgdGlsdCA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy50aWx0KVxuICAgICAgICA/IG1hcFByb3BzLnRpbHRcbiAgICAgICAgOiBudWxsO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgZWZmZWN0IHJ1bnMgZm9yIGV2ZXJ5IHJlbmRlciBvZiB0aGUgbWFwIGNvbXBvbmVudCBhbmQgY2hlY2tzXG4gICAgLy8gaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIGtub3duIHN0YXRlIG9mIHRoZSBtYXAgaW5zdGFuY2VcbiAgICAvLyAoY2FtZXJhU3RhdGVSZWYsIHdoaWNoIGlzIHVwZGF0ZWQgYnkgYWxsIGJvdW5kc19jaGFuZ2VkIGV2ZW50cykgYW5kIHRoZVxuICAgIC8vIGRlc2lyZWQgc3RhdGUgaW4gdGhlIHByb3BzLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXh0Q2FtZXJhID0ge307XG4gICAgICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAobGF0ICE9PSBudWxsICYmXG4gICAgICAgICAgICBsbmcgIT09IG51bGwgJiZcbiAgICAgICAgICAgIChjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sYXQgIT09IGxhdCB8fFxuICAgICAgICAgICAgICAgIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuY2VudGVyLmxuZyAhPT0gbG5nKSkge1xuICAgICAgICAgICAgbmV4dENhbWVyYS5jZW50ZXIgPSB7IGxhdCwgbG5nIH07XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvb20gIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC56b29tICE9PSB6b29tKSB7XG4gICAgICAgICAgICBuZXh0Q2FtZXJhLnpvb20gPSB6b29tO1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkaW5nICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuaGVhZGluZyAhPT0gaGVhZGluZykge1xuICAgICAgICAgICAgbmV4dENhbWVyYS5oZWFkaW5nID0gaGVhZGluZztcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGlsdCAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LnRpbHQgIT09IHRpbHQpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEudGlsdCA9IHRpbHQ7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICBtYXAubW92ZUNhbWVyYShuZXh0Q2FtZXJhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5jb25zdCBBdXRoRmFpbHVyZU1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHpJbmRleDogOTk5LFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhGbG93OiAnY29sdW1uIG5vd3JhcCcsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgZm9udFNpemU6ICcuOHJlbScsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjYpJyxcbiAgICAgICAgYmFja2dyb3VuZDogJyNkZGRkZGQnLFxuICAgICAgICBwYWRkaW5nOiAnMXJlbSAxLjVyZW0nXG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIFwiRXJyb3I6IEF1dGhGYWlsdXJlXCIpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLFxuICAgICAgICAgICAgXCJBIHByb2JsZW0gd2l0aCB5b3VyIEFQSSBrZXkgcHJldmVudHMgdGhlIG1hcCBmcm9tIHJlbmRlcmluZyBjb3JyZWN0bHkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHZhbHVlIG9mIHRoZSBcIixcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIG51bGwsIFwiQVBJUHJvdmlkZXIuYXBpS2V5XCIpLFxuICAgICAgICAgICAgXCIgcHJvcCBpcyBjb3JyZWN0LiBDaGVjayB0aGUgZXJyb3ItbWVzc2FnZSBpbiB0aGUgY29uc29sZSBmb3IgZnVydGhlciBkZXRhaWxzLlwiKSkpO1xufTtcblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoKSB7XG4gICAgY29uc3QgW2VsLCBzZXRFbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCByZWYgPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IHNldEVsKHZhbHVlKSwgW3NldEVsXSk7XG4gICAgcmV0dXJuIFtlbCwgcmVmXTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJIGlzIGxvYWRlZFxuICovXG5mdW5jdGlvbiB1c2VBcGlJc0xvYWRlZCgpIHtcbiAgICBjb25zdCBzdGF0dXMgPSB1c2VBcGlMb2FkaW5nU3RhdHVzKCk7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gQVBJTG9hZGluZ1N0YXR1cy5MT0FERUQ7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7XG4gICAgcmV0dXJuIGZvcmNlVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCb3VuZHNDaGFuZ2UobWFwLCByZWYpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgY29uc3QgaGVhZGluZyA9IG1hcC5nZXRIZWFkaW5nKCkgfHwgMDtcbiAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICBpZiAoIWNlbnRlciB8fCAhYm91bmRzIHx8ICFOdW1iZXIuaXNGaW5pdGUoem9vbSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdXNlVHJhY2tlZENhbWVyYVN0YXRlXSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArXG4gICAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLiBUaGlzIGlzIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uIFBsZWFzZSAnICtcbiAgICAgICAgICAgICdyZXBvcnQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2dsL3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy9uZXcnKTtcbiAgICB9XG4gICAgLy8gZml4bWU6IGRvIHdlIG5lZWQgdGhlIGB1bmRlZmluZWRgIGNhc2VzIGZvciB0aGUgY2FtZXJhLXBhcmFtcz8gV2hlbiBhcmUgdGhleSB1c2VkIGluIHRoZSBtYXBzIEFQST9cbiAgICBPYmplY3QuYXNzaWduKHJlZi5jdXJyZW50LCB7XG4gICAgICAgIGNlbnRlcjogKGNlbnRlciA9PT0gbnVsbCB8fCBjZW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbnRlci50b0pTT04oKSkgfHwgeyBsYXQ6IDAsIGxuZzogMCB9LFxuICAgICAgICB6b29tOiB6b29tIHx8IDAsXG4gICAgICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgICAgIHRpbHQ6IHRpbHRcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG11dGFibGUgcmVmIG9iamVjdCB0byB0cmFjayB0aGUgbGFzdCBrbm93biBzdGF0ZSBvZiB0aGUgbWFwIGNhbWVyYS5cbiAqIFRoaXMgaXMgdXNlZCBpbiBgdXNlTWFwQ2FtZXJhUGFyYW1zYCB0byByZWR1Y2Ugc3R1dHRlcmluZyBpbiBub3JtYWwgb3BlcmF0aW9uXG4gKiBieSBhdm9pZGluZyB1cGRhdGVzIG9mIHRoZSBtYXAgY2FtZXJhIHdpdGggdmFsdWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLlxuICovXG5mdW5jdGlvbiB1c2VUcmFja2VkQ2FtZXJhU3RhdGVSZWYobWFwKSB7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih7XG4gICAgICAgIGNlbnRlcjogeyBsYXQ6IDAsIGxuZzogMCB9LFxuICAgICAgICBoZWFkaW5nOiAwLFxuICAgICAgICB0aWx0OiAwLFxuICAgICAgICB6b29tOiAwXG4gICAgfSk7XG4gICAgLy8gUmVjb3JkIGNhbWVyYSBzdGF0ZSB3aXRoIGV2ZXJ5IGJvdW5kc19jaGFuZ2VkIGV2ZW50IGRpc3BhdGNoZWQgYnkgdGhlIG1hcC5cbiAgICAvLyBUaGlzIGRhdGEgaXMgdXNlZCB0byBwcmV2ZW50IGZlZWRpbmcgdGhlc2UgdmFsdWVzIGJhY2sgdG8gdGhlXG4gICAgLy8gbWFwLWluc3RhbmNlIHdoZW4gYSB0eXBpY2FsIFwiY29udHJvbGxlZCBjb21wb25lbnRcIiBzZXR1cCAoc3RhdGUgdmFyaWFibGUgaXNcbiAgICAvLyBmZWQgaW50byBhbmQgdXBkYXRlZCBieSB0aGUgbWFwKS5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZUJvdW5kc0NoYW5nZShtYXAsIHJlZik7XG4gICAgICAgICAgICAvLyBXaGVuIGFuIGV2ZW50IGlzIG9jY3VyZWQsIHdlIGhhdmUgdG8gdXBkYXRlIGR1cmluZyB0aGUgbmV4dCBjeWNsZS5cbiAgICAgICAgICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBjb3VsZCBkZWNpZGUgdG8gaWdub3JlIHRoZSBldmVudCBhbmQgbm90IHVwZGF0ZSBhbnlcbiAgICAgICAgICAgIC8vIGNhbWVyYSBwcm9wcyBvZiB0aGUgbWFwLCBtZWFuaW5nIHRoYXQgaW4gdGhhdCBjYXNlIHdlIHdpbGwgaGF2ZSB0b1xuICAgICAgICAgICAgLy8gJ3VuZG8nIHRoZSBjaGFuZ2UgdG8gdGhlIGNhbWVyYS5cbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW21hcCwgZm9yY2VVcGRhdGVdKTtcbiAgICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFN0b3JlcyBhIHN0YWNrIG9mIG1hcC1pbnN0YW5jZXMgZm9yIGVhY2ggbWFwSWQuIFdoZW5ldmVyIGFuXG4gKiBpbnN0YW5jZSBpcyB1c2VkLCBpdCBpcyByZW1vdmVkIGZyb20gdGhlIHN0YWNrIHdoaWxlIGluIHVzZSxcbiAqIGFuZCByZXR1cm5lZCB0byB0aGUgc3RhY2sgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzLlxuICogVGhpcyBhbGxvd3MgdXMgdG8gY29ycmVjdGx5IGltcGxlbWVudCBjYWNoaW5nIGZvciBtdWx0aXBsZVxuICogbWFwcyBvbSB0aGUgc2FtZSBwYWdlLCB3aGlsZSByZXVzaW5nIGFzIG11Y2ggYXMgcG9zc2libGUuXG4gKlxuICogRklYTUU6IHdoaWxlIGl0IHNob3VsZCBpbiB0aGVvcnkgYmUgcG9zc2libGUgdG8gcmV1c2UgbWFwcyBzb2xlbHlcbiAqICAgYmFzZWQgb24gdGhlIG1hcElkIChhcyBhbGwgb3RoZXIgcGFyYW1ldGVycyBjYW4gYmUgY2hhbmdlZCBhdFxuICogICBydW50aW1lKSwgd2UgZG9uJ3QgeWV0IGhhdmUgZ29vZCBlbm91Z2ggdHJhY2tpbmcgb2Ygb3B0aW9ucyB0b1xuICogICByZWxpYWJseSB1bnNldCBhbGwgdGhlIG9wdGlvbnMgdGhhdCBoYXZlIGJlZW4gc2V0LlxuICovXG5jbGFzcyBDYWNoZWRNYXBTdGFjayB7XG4gICAgc3RhdGljIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1trZXldICYmIHRoaXMuZW50cmllc1trZXldLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHN0YXRpYyBwb3Aoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyaWVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1trZXldLnBvcCgpIHx8IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBwdXNoKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudHJpZXNba2V5XSlcbiAgICAgICAgICAgIHRoaXMuZW50cmllc1trZXldID0gW107XG4gICAgICAgIHRoaXMuZW50cmllc1trZXldLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbkNhY2hlZE1hcFN0YWNrLmVudHJpZXMgPSB7fTtcbi8qKlxuICogVGhlIG1haW4gaG9vayB0YWtlcyBjYXJlIG9mIGNyZWF0aW5nIG1hcC1pbnN0YW5jZXMgYW5kIHJlZ2lzdGVyaW5nIHRoZW0gaW5cbiAqIHRoZSBhcGktcHJvdmlkZXIgY29udGV4dC5cbiAqIEByZXR1cm4gYSB0dXBsZSBvZiB0aGUgbWFwLWluc3RhbmNlIGNyZWF0ZWQgKG9yIG51bGwpIGFuZCB0aGUgY2FsbGJhY2tcbiAqICAgcmVmIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBhc3MgdGhlIG1hcC1jb250YWluZXIgaW50byB0aGlzIGhvb2suXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwSW5zdGFuY2UocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gICAgY29uc3QgW21hcCwgc2V0TWFwXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtjb250YWluZXIsIGNvbnRhaW5lclJlZl0gPSB1c2VDYWxsYmFja1JlZigpO1xuICAgIGNvbnN0IGNhbWVyYVN0YXRlUmVmID0gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCk7XG4gICAgY29uc3QgeyBpZCwgZGVmYXVsdEJvdW5kcywgZGVmYXVsdENlbnRlciwgZGVmYXVsdFpvb20sIGRlZmF1bHRIZWFkaW5nLCBkZWZhdWx0VGlsdCwgcmV1c2VNYXBzLCByZW5kZXJpbmdUeXBlLCBjb2xvclNjaGVtZSB9ID0gcHJvcHMsIG1hcE9wdGlvbnMgPSBfX3Jlc3QocHJvcHMsIFtcImlkXCIsIFwiZGVmYXVsdEJvdW5kc1wiLCBcImRlZmF1bHRDZW50ZXJcIiwgXCJkZWZhdWx0Wm9vbVwiLCBcImRlZmF1bHRIZWFkaW5nXCIsIFwiZGVmYXVsdFRpbHRcIiwgXCJyZXVzZU1hcHNcIiwgXCJyZW5kZXJpbmdUeXBlXCIsIFwiY29sb3JTY2hlbWVcIl0pO1xuICAgIGNvbnN0IGhhc1pvb20gPSBwcm9wcy56b29tICE9PSB1bmRlZmluZWQgfHwgcHJvcHMuZGVmYXVsdFpvb20gIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYXNDZW50ZXIgPSBwcm9wcy5jZW50ZXIgIT09IHVuZGVmaW5lZCB8fCBwcm9wcy5kZWZhdWx0Q2VudGVyICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFkZWZhdWx0Qm91bmRzICYmICghaGFzWm9vbSB8fCAhaGFzQ2VudGVyKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJzxNYXA+IGNvbXBvbmVudCBpcyBtaXNzaW5nIGNvbmZpZ3VyYXRpb24uICcgK1xuICAgICAgICAgICAgJ1lvdSBoYXZlIHRvIHByb3ZpZGUgem9vbSBhbmQgY2VudGVyICh2aWEgdGhlIGB6b29tYC9gZGVmYXVsdFpvb21gIGFuZCAnICtcbiAgICAgICAgICAgICdgY2VudGVyYC9gZGVmYXVsdENlbnRlcmAgcHJvcHMpIG9yIHNwZWNpZnkgdGhlIHJlZ2lvbiB0byBzaG93IHVzaW5nICcgK1xuICAgICAgICAgICAgJ2BkZWZhdWx0Qm91bmRzYC4gU2VlICcgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vdmlzZ2wuZ2l0aHViLmlvL3JlYWN0LWdvb2dsZS1tYXBzL2RvY3MvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL21hcCNyZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBhcHBseSBkZWZhdWx0IGNhbWVyYSBwcm9wcyBpZiBhdmFpbGFibGUgYW5kIG5vdCBvdmVyd3JpdHRlbiBieSBjb250cm9sbGVkIHByb3BzXG4gICAgaWYgKCFtYXBPcHRpb25zLmNlbnRlciAmJiBkZWZhdWx0Q2VudGVyKVxuICAgICAgICBtYXBPcHRpb25zLmNlbnRlciA9IGRlZmF1bHRDZW50ZXI7XG4gICAgaWYgKCFtYXBPcHRpb25zLnpvb20gJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRab29tKSlcbiAgICAgICAgbWFwT3B0aW9ucy56b29tID0gZGVmYXVsdFpvb207XG4gICAgaWYgKCFtYXBPcHRpb25zLmhlYWRpbmcgJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRIZWFkaW5nKSlcbiAgICAgICAgbWFwT3B0aW9ucy5oZWFkaW5nID0gZGVmYXVsdEhlYWRpbmc7XG4gICAgaWYgKCFtYXBPcHRpb25zLnRpbHQgJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRUaWx0KSlcbiAgICAgICAgbWFwT3B0aW9ucy50aWx0ID0gZGVmYXVsdFRpbHQ7XG4gICAgLy8gSGFuZGxlIGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkc1xuICAgIGNvbnN0IGN1c3RvbUlkcyA9IG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzO1xuICAgIGlmIChjdXN0b21JZHMgPT0gbnVsbCkge1xuICAgICAgICAvLyBOb3Qgc3BlY2lmaWVkIC0gdXNlIGNvbnRleHQgZGVmYXVsdCAod2hpY2ggbWF5IGJlIG51bGwgaWYgZGlzYWJsZWQpXG4gICAgICAgIG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID1cbiAgICAgICAgICAgIGNvbnRleHQuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2UgY29udGV4dCBkZWZhdWx0cyB3aXRoIGN1c3RvbSBJRHNcbiAgICAgICAgbWFwT3B0aW9ucy5pbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSBbXG4gICAgICAgICAgICAuLi4oY29udGV4dC5pbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgfHwgW10pLFxuICAgICAgICAgICAgLi4uY3VzdG9tSWRzXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1hcE9wdGlvbnMpKVxuICAgICAgICBpZiAobWFwT3B0aW9uc1trZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkZWxldGUgbWFwT3B0aW9uc1trZXldO1xuICAgIGNvbnN0IHNhdmVkTWFwU3RhdGVSZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgICAvLyBjcmVhdGUgdGhlIG1hcCBpbnN0YW5jZSBhbmQgcmVnaXN0ZXIgaXQgaW4gdGhlIGNvbnRleHRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhYXBpSXNMb2FkZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYWRkTWFwSW5zdGFuY2UsIHJlbW92ZU1hcEluc3RhbmNlIH0gPSBjb250ZXh0O1xuICAgICAgICAvLyBub3RlOiBjb2xvclNjaGVtZSAodXBjb21pbmcgZmVhdHVyZSkgaXNuJ3QgeWV0IGluIHRoZSB0eXBpbmdzLCByZW1vdmUgb25jZSB0aGF0IGlzIGZpeGVkOlxuICAgICAgICBjb25zdCB7IG1hcElkIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHttYXBJZCB8fCAnZGVmYXVsdCd9OiR7cmVuZGVyaW5nVHlwZSB8fCAnZGVmYXVsdCd9OiR7Y29sb3JTY2hlbWUgfHwgJ0xJR0hUJ31gO1xuICAgICAgICBsZXQgbWFwRGl2O1xuICAgICAgICBsZXQgbWFwO1xuICAgICAgICBpZiAocmV1c2VNYXBzICYmIENhY2hlZE1hcFN0YWNrLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgIG1hcCA9IENhY2hlZE1hcFN0YWNrLnBvcChjYWNoZUtleSk7XG4gICAgICAgICAgICBtYXBEaXYgPSBtYXAuZ2V0RGl2KCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWFwRGl2KTtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZGV0YWNoaW5nIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSBsZXRzIHRoZSBtYXAgZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0XG4gICAgICAgICAgICAvLyBzaXplLCBzZXR0aW5nIHRoZSBjZW50ZXIgd2lsbCB0cmlnZ2VyIHJlbG9hZGluZyB0aGUgbWFwLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBtYXAuc2V0Q2VudGVyKG1hcC5nZXRDZW50ZXIoKSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFwRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtYXBEaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICAgICAgICBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKG1hcERpdiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1hcE9wdGlvbnMpLCAocmVuZGVyaW5nVHlwZVxuICAgICAgICAgICAgICAgID8geyByZW5kZXJpbmdUeXBlOiByZW5kZXJpbmdUeXBlIH1cbiAgICAgICAgICAgICAgICA6IHt9KSksIChjb2xvclNjaGVtZVxuICAgICAgICAgICAgICAgID8geyBjb2xvclNjaGVtZTogY29sb3JTY2hlbWUgfVxuICAgICAgICAgICAgICAgIDoge30pKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TWFwKG1hcCk7XG4gICAgICAgIGFkZE1hcEluc3RhbmNlKG1hcCwgaWQpO1xuICAgICAgICBpZiAoZGVmYXVsdEJvdW5kcykge1xuICAgICAgICAgICAgY29uc3QgeyBwYWRkaW5nIH0gPSBkZWZhdWx0Qm91bmRzLCBkZWZCb3VuZHMgPSBfX3Jlc3QoZGVmYXVsdEJvdW5kcywgW1wicGFkZGluZ1wiXSk7XG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKGRlZkJvdW5kcywgcGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBtYXAgbm90IHJlbmRlcmluZyBkdWUgdG8gbWlzc2luZyBjb25maWd1cmF0aW9uXG4gICAgICAgIGVsc2UgaWYgKCFoYXNab29tIHx8ICFoYXNDZW50ZXIpIHtcbiAgICAgICAgICAgIG1hcC5maXRCb3VuZHMoeyBlYXN0OiAxODAsIHdlc3Q6IC0xODAsIHNvdXRoOiAtOTAsIG5vcnRoOiA5MCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc2F2ZWRNYXBTdGF0ZSBpcyB1c2VkIHRvIHJlc3RvcmUgdGhlIGNhbWVyYSBwYXJhbWV0ZXJzIHdoZW4gdGhlIG1hcElkIGlzIGNoYW5nZWRcbiAgICAgICAgaWYgKHNhdmVkTWFwU3RhdGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBtYXBJZDogc2F2ZWRNYXBJZCwgY2FtZXJhU3RhdGU6IHNhdmVkQ2FtZXJhU3RhdGUgfSA9IHNhdmVkTWFwU3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzYXZlZE1hcElkICE9PSBtYXBJZCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHNhdmVkQ2FtZXJhU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbWFwSWQsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgICAgIGNhbWVyYVN0YXRlOiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZGV0YWNoIHRoZSBtYXAtZGl2IGZyb20gdGhlIGRvbVxuICAgICAgICAgICAgbWFwRGl2LnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKHJldXNlTWFwcykge1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggYmFjayBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICBDYWNoZWRNYXBTdGFjay5wdXNoKGNhY2hlS2V5LCBtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudC1saXN0ZW5lcnMgdG8gbWluaW1pemUgdGhlIHBvc3NpYmlsaXR5IG9mIG1lbW9yeS1sZWFrc1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnMobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1hcChudWxsKTtcbiAgICAgICAgICAgIHJlbW92ZU1hcEluc3RhbmNlKGlkKTtcbiAgICAgICAgfTtcbiAgICB9LCBcbiAgICAvLyBzb21lIGRlcGVuZGVuY2llcyBhcmUgaWdub3JlZCBpbiB0aGUgbGlzdCBiZWxvdzpcbiAgICAvLyAgLSBkZWZhdWx0Qm91bmRzIGFuZCB0aGUgZGVmYXVsdCogY2FtZXJhIHByb3BzIHdpbGwgb25seSBiZSB1c2VkIG9uY2UsIGFuZFxuICAgIC8vICAgIGNoYW5nZXMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAvLyAgLSBtYXBPcHRpb25zIGhhcyBzcGVjaWFsIGhvb2tzIHRoYXQgdGFrZSBjYXJlIG9mIHVwZGF0aW5nIHRoZSBvcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhcGlJc0xvYWRlZCxcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRoZXNlIHByb3BzIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYW5kIHJlcXVpcmUgYSBuZXdcbiAgICAgICAgLy8gaW5zdGFuY2UgdG8gYmUgY3JlYXRlZFxuICAgICAgICBwcm9wcy5tYXBJZCxcbiAgICAgICAgcHJvcHMucmVuZGVyaW5nVHlwZSxcbiAgICAgICAgcHJvcHMuY29sb3JTY2hlbWVcbiAgICBdKTtcbiAgICByZXR1cm4gW21hcCwgY29udGFpbmVyUmVmLCBjYW1lcmFTdGF0ZVJlZl07XG59XG5cbmNvbnN0IEdvb2dsZU1hcHNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8vIENvbG9yU2NoZW1lIGFuZCBSZW5kZXJpbmdUeXBlIGFyZSByZWRlZmluZWQgaGVyZSB0byBtYWtlIHRoZW0gdXNhYmxlIGJlZm9yZSB0aGVcbi8vIG1hcHMgQVBJIGhhcyBiZWVuIGZ1bGx5IGxvYWRlZC5cbmNvbnN0IENvbG9yU2NoZW1lID0ge1xuICAgIERBUks6ICdEQVJLJyxcbiAgICBMSUdIVDogJ0xJR0hUJyxcbiAgICBGT0xMT1dfU1lTVEVNOiAnRk9MTE9XX1NZU1RFTSdcbn07XG5jb25zdCBSZW5kZXJpbmdUeXBlID0ge1xuICAgIFZFQ1RPUjogJ1ZFQ1RPUicsXG4gICAgUkFTVEVSOiAnUkFTVEVSJyxcbiAgICBVTklOSVRJQUxJWkVEOiAnVU5JTklUSUFMSVpFRCdcbn07XG5jb25zdCBNYXAgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBpZCwgY2xhc3NOYW1lLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgICBjb25zdCBsb2FkaW5nU3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxNYXA+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIDxBcGlQcm92aWRlcj4gY29tcG9uZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBbbWFwLCBtYXBSZWYsIGNhbWVyYVN0YXRlUmVmXSA9IHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KTtcbiAgICB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgcHJvcHMpO1xuICAgIHVzZU1hcEV2ZW50cyhtYXAsIHByb3BzKTtcbiAgICB1c2VNYXBPcHRpb25zKG1hcCwgcHJvcHMpO1xuICAgIGNvbnN0IGlzRGVja0dsQ29udHJvbGxlZCA9IHVzZURlY2tHTENhbWVyYVVwZGF0ZShtYXAsIHByb3BzKTtcbiAgICBjb25zdCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5ID0gISFwcm9wcy5jb250cm9sbGVkO1xuICAgIC8vIGRpc2FibGUgaW50ZXJhY3Rpb25zIHdpdGggdGhlIG1hcCBmb3IgZXh0ZXJuYWxseSBjb250cm9sbGVkIG1hcHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gZml4bWU6IHRoaXMgZG9lc24ndCBzZWVtIHRvIGJlbG9uZyBoZXJlIChhbmQgaXQncyBtb3N0bHkgdGhlcmUgZm9yIGNvbnZlbmllbmNlIGFueXdheSkuXG4gICAgICAgIC8vICAgVGhlIHJlYXNvbmluZyBpcyB0aGF0IGEgZGVjay5nbCBjYW52YXMgd2lsbCBiZSBwdXQgb24gdG9wIG9mIHRoZSBtYXAsIHJlbmRlcmluZ1xuICAgICAgICAvLyAgIGFueSBkZWZhdWx0IG1hcCBjb250cm9scyBwcmV0dHkgbXVjaCB1c2VsZXNzXG4gICAgICAgIGlmIChpc0RlY2tHbENvbnRyb2xsZWQpIHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHsgZGlzYWJsZURlZmF1bHRVSTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNhYmxlIGFsbCBjb250cm9sLWlucHV0cyB3aGVuIHRoZSBtYXAgaXMgY29udHJvbGxlZCBleHRlcm5hbGx5XG4gICAgICAgIGlmIChpc0RlY2tHbENvbnRyb2xsZWQgfHwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSkge1xuICAgICAgICAgICAgbWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGdlc3R1cmVIYW5kbGluZzogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGtleWJvYXJkU2hvcnRjdXRzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlSGFuZGxpbmc6IHByb3BzLmdlc3R1cmVIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgbWFwLFxuICAgICAgICBpc0RlY2tHbENvbnRyb2xsZWQsXG4gICAgICAgIGlzQ29udHJvbGxlZEV4dGVybmFsbHksXG4gICAgICAgIHByb3BzLmdlc3R1cmVIYW5kbGluZyxcbiAgICAgICAgcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNcbiAgICBdKTtcbiAgICAvLyBzZXR1cCBhIHN0YWJsZSBjYW1lcmFPcHRpb25zIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGRlcGVuZGVuY3lcbiAgICBjb25zdCBjZW50ZXIgPSBwcm9wcy5jZW50ZXIgPyB0b0xhdExuZ0xpdGVyYWwocHJvcHMuY2VudGVyKSA6IG51bGw7XG4gICAgbGV0IGxhdCA9IG51bGw7XG4gICAgbGV0IGxuZyA9IG51bGw7XG4gICAgaWYgKGNlbnRlciAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sbmcpKSB7XG4gICAgICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgICAgIGxuZyA9IGNlbnRlci5sbmc7XG4gICAgfVxuICAgIGNvbnN0IGNhbWVyYU9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IHsgbGF0OiBsYXQgIT09IG51bGwgJiYgbGF0ICE9PSB2b2lkIDAgPyBsYXQgOiAwLCBsbmc6IGxuZyAhPT0gbnVsbCAmJiBsbmcgIT09IHZvaWQgMCA/IGxuZyA6IDAgfSxcbiAgICAgICAgICAgIHpvb206IChfYSA9IHByb3BzLnpvb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICBoZWFkaW5nOiAoX2IgPSBwcm9wcy5oZWFkaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLFxuICAgICAgICAgICAgdGlsdDogKF9jID0gcHJvcHMudGlsdCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMFxuICAgICAgICB9O1xuICAgIH0sIFtsYXQsIGxuZywgcHJvcHMuem9vbSwgcHJvcHMuaGVhZGluZywgcHJvcHMudGlsdF0pO1xuICAgIC8vIGV4dGVybmFsbHkgY29udHJvbGxlZCBtb2RlOiByZWplY3QgYWxsIGNhbWVyYSBjaGFuZ2VzIHRoYXQgZG9uJ3QgY29ycmVzcG9uZCB0byBjaGFuZ2VzIGluIHByb3BzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXAgfHwgIWlzQ29udHJvbGxlZEV4dGVybmFsbHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcC5tb3ZlQ2FtZXJhKGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IG1hcC5hZGRMaXN0ZW5lcignYm91bmRzX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9LCBbbWFwLCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LCBjYW1lcmFPcHRpb25zXSk7XG4gICAgY29uc3QgY29tYmluZWRTdHlsZSA9IHVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIFxuICAgICAgICAvLyB3aGVuIHVzaW5nIGRlY2tnbCwgdGhlIG1hcCBzaG91bGQgYmUgc2VudCB0byB0aGUgYmFja1xuICAgICAgICB6SW5kZXg6IGlzRGVja0dsQ29udHJvbGxlZCA/IC0xIDogMCB9LCBzdHlsZSkpLCBbc3R5bGUsIGlzRGVja0dsQ29udHJvbGxlZF0pO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgbWFwIH0pLCBbbWFwXSk7XG4gICAgaWYgKGxvYWRpbmdTdGF0dXMgPT09IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSwgKGNsYXNzTmFtZSA/IHt9IDogY29tYmluZWRTdHlsZSkpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBdXRoRmFpbHVyZU1lc3NhZ2UsIG51bGwpKSk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBtYXBSZWYsIFwiZGF0YS10ZXN0aWRcIjogJ21hcCcsIHN0eWxlOiBjbGFzc05hbWUgPyB1bmRlZmluZWQgOiBjb21iaW5lZFN0eWxlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCAoaWQgPyB7IGlkIH0gOiB7fSkpLCBtYXAgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChHb29nbGVNYXBzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKSkgOiBudWxsKSk7XG59O1xuLy8gVGhlIGRlY2tHTFZpZXdQcm9wcyBmbGFnIGhlcmUgaW5kaWNhdGVzIHRvIGRlY2suZ2wgdGhhdCB0aGUgTWFwIGNvbXBvbmVudCBpc1xuLy8gYWJsZSB0byBoYW5kbGUgdmlld1Byb3BzIGZyb20gZGVjay5nbCB3aGVuIGRlY2suZ2wgaXMgdXNlZCB0byBjb250cm9sIHRoZSBtYXAuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuTWFwLmRlY2tHTFZpZXdQcm9wcyA9IHRydWU7XG5cbmNvbnN0IHNob3duTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBsb2dFcnJvck9uY2UoLi4uYXJncykge1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICAgIGlmICghc2hvd25NZXNzYWdlcy5oYXMoa2V5KSkge1xuICAgICAgICBzaG93bk1lc3NhZ2VzLmFkZChrZXkpO1xuICAgICAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBtYXAtaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dC4gVGhpcyBpcyBlaXRoZXIgYW4gaW5zdGFuY2VcbiAqIGlkZW50aWZpZWQgYnkgaWQgb3IgdGhlIHBhcmVudCBtYXAgaW5zdGFuY2UgaWYgbm8gaWQgaXMgc3BlY2lmaWVkLlxuICogUmV0dXJucyBudWxsIGlmIG5laXRoZXIgY2FuIGJlIGZvdW5kLlxuICovXG5jb25zdCB1c2VNYXAgPSAoaWQgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICAgIGNvbnN0IHsgbWFwIH0gPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSB8fCB7fTtcbiAgICBpZiAoY3R4ID09PSBudWxsKSB7XG4gICAgICAgIGxvZ0Vycm9yT25jZSgndXNlTWFwKCk6IGZhaWxlZCB0byByZXRyaWV2ZSBBUElQcm92aWRlckNvbnRleHQuICcgK1xuICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IHRoZSA8QVBJUHJvdmlkZXI+IGNvbXBvbmVudCBleGlzdHMgYW5kIHRoYXQgdGhlICcgK1xuICAgICAgICAgICAgJ2NvbXBvbmVudCB5b3UgYXJlIGNhbGxpbmcgYHVzZU1hcCgpYCBmcm9tIGlzIGEgc2libGluZyBvZiB0aGUgJyArXG4gICAgICAgICAgICAnPEFQSVByb3ZpZGVyPi4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgbWFwSW5zdGFuY2VzIH0gPSBjdHg7XG4gICAgLy8gaWYgYW4gaWQgaXMgc3BlY2lmaWVkLCB0aGUgY29ycmVzcG9uZGluZyBtYXAgb3IgbnVsbCBpcyByZXR1cm5lZFxuICAgIGlmIChpZCAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG1hcEluc3RhbmNlc1tpZF0gfHwgbnVsbDtcbiAgICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgIGlmIChtYXApXG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgLy8gZmluYWxseSwgcmV0dXJuIHRoZSBkZWZhdWx0IG1hcCBpbnN0YW5jZVxuICAgIHJldHVybiBtYXBJbnN0YW5jZXNbJ2RlZmF1bHQnXSB8fCBudWxsO1xufTtcblxuZnVuY3Rpb24gdXNlTWFwc0xpYnJhcnkobmFtZSkge1xuICAgIGNvbnN0IGFwaUlzTG9hZGVkID0gdXNlQXBpSXNMb2FkZWQoKTtcbiAgICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhcGlJc0xvYWRlZCB8fCAhY3R4KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUcmlnZ2VyIGxvYWRpbmcgdGhlIGxpYnJhcmllcyB2aWEgb3VyIHByb3h5LW1ldGhvZC5cbiAgICAgICAgLy8gVGhlIHJldHVybmVkIHByb21pc2UgaXMgaWdub3JlZCwgc2luY2UgaW1wb3J0TGlicmFyeSB3aWxsIHVwZGF0ZSBsb2FkZWRMaWJyYXJpZXNcbiAgICAgICAgLy8gbGlzdCBpbiB0aGUgY29udGV4dCwgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgICAgdm9pZCBjdHguaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICB9LCBbYXBpSXNMb2FkZWQsIGN0eCwgbmFtZV0pO1xuICAgIHJldHVybiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmxvYWRlZExpYnJhcmllc1tuYW1lXSkgfHwgbnVsbDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gYmluZCBldmVudHMgdG8gTWFwcyBKYXZhU2NyaXB0IEFQSSBvYmplY3RzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcHNFdmVudExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhbmFtZSB8fCAhY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vKipcbiAqIEludGVybmFsbHkgdXNlZCB0byBjb3B5IHZhbHVlcyBmcm9tIHByb3BzIGludG8gQVBJLU9iamVjdHNcbiAqIHdoZW5ldmVyIHRoZXkgY2hhbmdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VQcm9wQmluZGluZyhvYmplY3QsIHByb3AsIHZhbHVlKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFvYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9pbW11dGFiaWxpdHlcbiAgICAgICAgb2JqZWN0W3Byb3BdID0gdmFsdWU7XG4gICAgfSwgW29iamVjdCwgcHJvcCwgdmFsdWVdKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gYmluZCBldmVudHMgdG8gRE9NIG5vZGVzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURvbUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICFuYW1lIHx8ICFjYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgIH0sIFt0YXJnZXQsIG5hbWUsIGNhbGxiYWNrXSk7XG59XG5cbi8vIEdsb2JhbCBzdHlsZSBtYW5hZ2VyIHRvIHRyYWNrIHJlbmRlcmVkIHN0eWxlcyBhbmQgYXZvaWQgZHVwbGljYXRlc1xuY2xhc3MgR2xvYmFsU3R5bGVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBnZXRTdHlsZUVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1yZ20tYW5jaG9yLXN0eWxlcycsICcnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlRWxlbWVudDtcbiAgICB9XG4gICAgYWRkQWR2YW5jZWRNYXJrZXJQb2ludGVyRXZlbnRzT3ZlcndyaXRlKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZFN0eWxlcy5oYXMoJ21hcmtlci1wb2ludGVyLWV2ZW50cycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gdGhpcy5nZXRTdHlsZUVsZW1lbnQoKTtcbiAgICAgICAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ICs9IGBcbiAgICAgIGdtcC1hZHZhbmNlZC1tYXJrZXJbZGF0YS1vcmlnaW49J3JnbSddIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICBgO1xuICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzLmFkZCgnbWFya2VyLXBvaW50ZXItZXZlbnRzJyk7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBnbG9iYWxTdHlsZU1hbmFnZXIgPSBuZXcgR2xvYmFsU3R5bGVNYW5hZ2VyKCk7XG5cbmZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJFcXVhbChtYWpvciwgbWlub3IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoKF9hID0gZ29vZ2xlID09PSBudWxsIHx8IGdvb2dsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ29vZ2xlLm1hcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52ZXJzaW9uKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCB2ZXJzaW9uID0gZ29vZ2xlLm1hcHMudmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGN1cnJlbnRNYWpvciA9IHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKTtcbiAgICBjb25zdCBjdXJyZW50TWlub3IgPSBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCk7XG4gICAgcmV0dXJuIChjdXJyZW50TWFqb3IgPiBtYWpvciB8fCAoY3VycmVudE1ham9yID09PSBtYWpvciAmJiBjdXJyZW50TWlub3IgPj0gbWlub3IpKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvaW1tdXRhYmlsaXR5ICovXG4vLyBUaGUgYHJlYWN0LWhvb2tzL2ltbXV0YWJpbGl0eWAgcnVsZSBpcyBkaXNhYmxlZCBpbiB0aGlzIGZpbGUgYmVjYXVzZSB0aGVcbi8vIGdvb2dsZS5tYXBzLm1hcmtlci5BZHZhbmNlZE1hcmtlckVsZW1lbnQgb2JqZWN0IGlzIGRlc2lnbmVkIHRvIGJlIG11dGF0ZWRcbi8vIGRpcmVjdGx5LiBUaGlzIGlzIGEgY29tbW9uIHBhdHRlcm4gd2hlbiB3b3JraW5nIHdpdGggaW1wZXJhdGl2ZSBBUElzIGxpa2Vcbi8vIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSS4gV2hpbGUgdGhpcyBnb2VzIGFnYWluc3QgdGhlIHByaW5jaXBsZXMgb2Zcbi8vIGltbXV0YWJsZSBzdGF0ZSBpbiBSZWFjdCwgaXQgaXMgYSBuZWNlc3NhcnkgZXZpbCB0byBpbnRlZ3JhdGUgd2l0aCB0aGVcbi8vIEdvb2dsZSBNYXBzIEFQSS4gVGhlIG11dGF0aW9ucyBhcmUgY2FyZWZ1bGx5IG1hbmFnZWQgd2l0aGluIHRoZSBgdXNlRWZmZWN0YFxuLy8gaG9va3MgdG8gZW5zdXJlIHRoYXQgdGhleSBvbmx5IGhhcHBlbiB3aGVuIHRoZSBwcm9wcyBjaGFuZ2UuXG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db2xsaXNpb25CZWhhdmlvcmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb2xsaXNpb25CZWhhdmlvciA9IHtcbiAgICBSRVFVSVJFRDogJ1JFUVVJUkVEJyxcbiAgICBSRVFVSVJFRF9BTkRfSElERVNfT1BUSU9OQUw6ICdSRVFVSVJFRF9BTkRfSElERVNfT1BUSU9OQUwnLFxuICAgIE9QVElPTkFMX0FORF9ISURFU19MT1dFUl9QUklPUklUWTogJ09QVElPTkFMX0FORF9ISURFU19MT1dFUl9QUklPUklUWSdcbn07XG5jb25zdCBBZHZhbmNlZE1hcmtlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuLy8gW3hQb3NpdGlvbiwgeVBvc2l0aW9uXSB3aGVuIHRoZSB0b3AgbGVmdCBjb3JuZXIgaXMgWzAsIDBdXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzaW5nIGBhbmNob3JQb3NpdGlvbmAgaXMgZGVwcmVjYXRlZC5cbiAqICAgVXNlIGBhbmNob3JMZWZ0YCBhbmQgYGFuY2hvclRvcGAgaW5zdGVhZC5cbiAqL1xuY29uc3QgQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludCA9IHtcbiAgICBUT1BfTEVGVDogWycwJScsICcwJSddLFxuICAgIFRPUF9DRU5URVI6IFsnNTAlJywgJzAlJ10sXG4gICAgVE9QOiBbJzUwJScsICcwJSddLFxuICAgIFRPUF9SSUdIVDogWycxMDAlJywgJzAlJ10sXG4gICAgTEVGVF9DRU5URVI6IFsnMCUnLCAnNTAlJ10sXG4gICAgTEVGVF9UT1A6IFsnMCUnLCAnMCUnXSxcbiAgICBMRUZUOiBbJzAlJywgJzUwJSddLFxuICAgIExFRlRfQk9UVE9NOiBbJzAlJywgJzEwMCUnXSxcbiAgICBSSUdIVF9UT1A6IFsnMTAwJScsICcwJSddLFxuICAgIFJJR0hUOiBbJzEwMCUnLCAnNTAlJ10sXG4gICAgUklHSFRfQ0VOVEVSOiBbJzEwMCUnLCAnNTAlJ10sXG4gICAgUklHSFRfQk9UVE9NOiBbJzEwMCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTV9MRUZUOiBbJzAlJywgJzEwMCUnXSxcbiAgICBCT1RUT01fQ0VOVEVSOiBbJzUwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NOiBbJzUwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NX1JJR0hUOiBbJzEwMCUnLCAnMTAwJSddLFxuICAgIENFTlRFUjogWyc1MCUnLCAnNTAlJ11cbn07XG5jb25zdCBBZHZhbmNlZE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBzdHlsZSwgY2xhc3NOYW1lLCBhbmNob3JQb2ludCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW21hcmtlciwgY29udGVudENvbnRhaW5lcl0gPSB1c2VBZHZhbmNlZE1hcmtlcihwcm9wcyk7XG4gICAgY29uc3QgYWR2YW5jZWRNYXJrZXJDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IChtYXJrZXIgPyB7IG1hcmtlciB9IDogbnVsbCksIFttYXJrZXJdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gICAgaWYgKCFjb250ZW50Q29udGFpbmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWR2YW5jZWRNYXJrZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZSB9LCBjcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrZXJDb250ZW50LCB7IGFuY2hvclBvaW50OiBhbmNob3JQb2ludCwgc3R5bGVzOiBzdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pLCBjb250ZW50Q29udGFpbmVyKSkpO1xufSk7XG5BZHZhbmNlZE1hcmtlci5kaXNwbGF5TmFtZSA9ICdBZHZhbmNlZE1hcmtlcic7XG5mdW5jdGlvbiB1c2VBZHZhbmNlZE1hcmtlclJlZigpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygobSkgPT4ge1xuICAgICAgICBzZXRNYXJrZXIobSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5mdW5jdGlvbiBpc0FkdmFuY2VkTWFya2VyKG1hcmtlcikge1xuICAgIHJldHVybiAobWFya2VyLmNvbnRlbnQgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG5jb25zdCBNYXJrZXJDb250ZW50ID0gKHsgY2hpbGRyZW4sIHN0eWxlcywgY2xhc3NOYW1lIH0pID0+IHtcbiAgICAvKiBBZHZhbmNlZE1hcmtlciBkaXYgdGhhdCB1c2VyIGNhbiBnaXZlIHN0eWxlcyBhbmQgY2xhc3NlcyAqL1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGVzIH0sIGNoaWxkcmVuKSk7XG59O1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NvbnRlbnRDb250YWluZXIsIHNldENvbnRlbnRDb250YWluZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgY29uc3QgbWFya2VyTGlicmFyeSA9IHVzZU1hcHNMaWJyYXJ5KCdtYXJrZXInKTtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBvbkNsaWNrLCBjbGFzc05hbWUsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvbkRyYWcsIG9uRHJhZ1N0YXJ0LCBvbkRyYWdFbmQsIGNvbGxpc2lvbkJlaGF2aW9yLCBjbGlja2FibGUsIGRyYWdnYWJsZSwgcG9zaXRpb24sIHRpdGxlLCB6SW5kZXgsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AgfSA9IHByb3BzO1xuICAgIGNvbnN0IG51bUNoaWxkcmVuID0gQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pO1xuICAgIC8vIGNyZWF0ZSBhbiBBZHZhbmNlZE1hcmtlckVsZW1lbnQgaW5zdGFuY2UgYW5kIGFkZCBpdCB0byB0aGUgbWFwIG9uY2UgYXZhaWxhYmxlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXAgfHwgIW1hcmtlckxpYnJhcnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBtYXJrZXJMaWJyYXJ5LkFkdmFuY2VkTWFya2VyRWxlbWVudCgpO1xuICAgICAgICBuZXdNYXJrZXIubWFwID0gbWFwO1xuICAgICAgICBzZXRNYXJrZXIobmV3TWFya2VyKTtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjb250YWluZXIgZm9yIG1hcmtlciBjb250ZW50IGlmIHRoZXJlIGFyZSBjaGlsZHJlblxuICAgICAgICBsZXQgY29udGVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAobnVtQ2hpbGRyZW4gPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbmV3TWFya2VyLmNvbnRlbnQgPSBjb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHNldENvbnRlbnRDb250YWluZXIoY29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdNYXJrZXIubWFwID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50ID09PSBudWxsIHx8IGNvbnRlbnRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgICAgICAgIHNldENvbnRlbnRDb250YWluZXIobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW21hcCwgbWFya2VyTGlicmFyeSwgbnVtQ2hpbGRyZW5dKTtcbiAgICAvLyBXaGVuIG5vIGNoaWxkcmVuIGFyZSBwcmVzZW50IHdlIGRvbid0IGhhdmUgb3VyIG93biB3cmFwcGVyIGRpdlxuICAgIC8vIHdoaWNoIHVzdWFsbHkgZ2V0cyB0aGUgdXNlciBwcm92aWRlZCBjbGFzc05hbWUuIEluIHRoaXMgY2FzZVxuICAgIC8vIHdlIHNldCB0aGUgY2xhc3NOYW1lIGRpcmVjdGx5IG9uIHRoZSBtYXJrZXIuY29udGVudCBlbGVtZW50IHRoYXQgY29tZXNcbiAgICAvLyB3aXRoIHRoZSBBZHZhbmNlZE1hcmtlci5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIShtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuY29udGVudCkgfHwgIWlzRWxlbWVudE5vZGUobWFya2VyLmNvbnRlbnQpIHx8IG51bUNoaWxkcmVuID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFya2VyLmNvbnRlbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lICE9PSBudWxsICYmIGNsYXNzTmFtZSAhPT0gdm9pZCAwID8gY2xhc3NOYW1lIDogJyc7XG4gICAgfSwgW21hcmtlciwgY2xhc3NOYW1lLCBudW1DaGlsZHJlbl0pO1xuICAgIHVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nKG1hcmtlciwgYW5jaG9yUG9pbnQsIGFuY2hvckxlZnQsIGFuY2hvclRvcCwgbnVtQ2hpbGRyZW4gPiAwKTtcbiAgICAvLyBjb3B5IG90aGVyIHByb3BzXG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAncG9zaXRpb24nLCBwb3NpdGlvbik7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAndGl0bGUnLCB0aXRsZSAhPT0gbnVsbCAmJiB0aXRsZSAhPT0gdm9pZCAwID8gdGl0bGUgOiAnJyk7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAnekluZGV4JywgekluZGV4KTtcbiAgICB1c2VQcm9wQmluZGluZyhtYXJrZXIsICdjb2xsaXNpb25CZWhhdmlvcicsIGNvbGxpc2lvbkJlaGF2aW9yKTtcbiAgICAvLyBzZXQgZ21wRHJhZ2dhYmxlIGZyb20gcHJvcHMgKHdoZW4gdW5zcGVjaWZpZWQsIGl0J3MgdHJ1ZSBpZiBhbnkgZHJhZy1ldmVudFxuICAgIC8vIGNhbGxiYWNrcyBhcmUgc3BlY2lmaWVkKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZHJhZ2dhYmxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgICBlbHNlIGlmIChvbkRyYWcgfHwgb25EcmFnU3RhcnQgfHwgb25EcmFnRW5kKVxuICAgICAgICAgICAgbWFya2VyLmdtcERyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hcmtlci5nbXBEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uRHJhZywgb25EcmFnRW5kLCBvbkRyYWdTdGFydF0pO1xuICAgIC8vIHNldCBnbXBDbGlja2FibGUgZnJvbSBwcm9wcyAod2hlbiB1bnNwZWNpZmllZCwgaXQncyB0cnVlIGlmIHRoZSBvbkNsaWNrIG9yIG9uZSBvZlxuICAgIC8vIHRoZSBob3ZlciBldmVudHMgY2FsbGJhY2tzIGFyZSBzcGVjaWZpZWQpXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGdtcENsaWNrYWJsZSA9IGNsaWNrYWJsZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uQ2xpY2spIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uTW91c2VFbnRlcikgfHxcbiAgICAgICAgICAgIEJvb2xlYW4ob25Nb3VzZUxlYXZlKTtcbiAgICAgICAgLy8gZ21wQ2xpY2thYmxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIGJldGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgICAgLy8gbWFwcyBhcGkgKGFzIG9mIDIwMjQtMTAtMTApXG4gICAgICAgIG1hcmtlci5nbXBDbGlja2FibGUgPSBnbXBDbGlja2FibGU7XG4gICAgICAgIC8vIGVuYWJsZSBwb2ludGVyIGV2ZW50cyBmb3IgdGhlIG1hcmtlcnMgd2l0aCBjdXN0b20gY29udGVudFxuICAgICAgICBpZiAoZ21wQ2xpY2thYmxlICYmIChtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuY29udGVudCkgJiYgaXNFbGVtZW50Tm9kZShtYXJrZXIuY29udGVudCkpIHtcbiAgICAgICAgICAgIG1hcmtlci5jb250ZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW21hcmtlciwgY2xpY2thYmxlLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZV0pO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgb25DbGljayk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIobWFya2VyLCAnZHJhZycsIG9uRHJhZyk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIobWFya2VyLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgIHVzZURvbUV2ZW50TGlzdGVuZXIobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmVsZW1lbnQsICdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICB1c2VEb21FdmVudExpc3RlbmVyKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5lbGVtZW50LCAnbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgcmV0dXJuIFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdO1xufVxuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJBbmNob3JpbmcobWFya2VyLCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wLCBoYXNDaGlsZHJlbikge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyIHx8ICFoYXNDaGlsZHJlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVGhlIGFuY2hvckxlZnQgYW5kIGFuY2hvclRvcCBvcHRpb25zIGFyZSBhdmFpbGFibGUgc2luY2UgdmVyc2lvbiAzLjYyLjljXG4gICAgICAgIC8vIFdpdGggdGhlIHJlbGVhc2Ugb2YgMy42NSAofk1heSAyMDI2KSB0aGVyZSB3aWxsIG5vIGxvbmdlciBiZSBhIHZlcnNpb25cbiAgICAgICAgLy8gdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGNvbnN0IGFuY2hvck9wdGlvbnNTdXBwb3J0ZWQgPSBpc1ZlcnNpb25HcmVhdGVyRXF1YWwoMywgNjIpO1xuICAgICAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG1hcmtlci5jb250ZW50O1xuICAgICAgICBpZiAoIWNvbnRlbnRFbGVtZW50IHx8ICFpc0VsZW1lbnROb2RlKGNvbnRlbnRFbGVtZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFuY2hvckxlZnQgIT09IHVuZGVmaW5lZCB8fCBhbmNob3JUb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFhbmNob3JPcHRpb25zU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZHZhbmNlZE1hcmtlcjogVGhlIGFuY2hvckxlZnQgYW5kIGFuY2hvclRvcCBwcm9wcyBhcmUgb25seSBzdXBwb3J0ZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICdpbiBHb29nbGUgTWFwcyBBUEkgdmVyc2lvbiAzLjYyIGFuZCBhYm92ZS4gJyArXG4gICAgICAgICAgICAgICAgICAgIGBUaGUgY3VycmVudCB2ZXJzaW9uIGlzICR7Z29vZ2xlLm1hcHMudmVyc2lvbn0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrZXIuYW5jaG9yTGVmdCA9IGFuY2hvckxlZnQ7XG4gICAgICAgICAgICBtYXJrZXIuYW5jaG9yVG9wID0gYW5jaG9yVG9wO1xuICAgICAgICAgICAgLy8gd2hlbiBhbmNob3JMZWZ0IGFuZC9vciBhbmNob3JUb3AgYXJlIHNldCwgd2UnbGwgaWdub3JlIHRoZSBhbmNob3JQb2ludFxuICAgICAgICAgICAgaWYgKGFuY2hvclBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FkdmFuY2VkTWFya2VyOiB0aGUgYW5jaG9yUG9pbnQgcHJvcCBpcyBpZ25vcmVkIHdoZW4gYW5jaG9yTGVmdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuZC9vciBhbmNob3JUb3AgYXJlIHNldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogYWRkIGNvbnNvbGUud2FybiBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHRvIGluZm9ybSBhYm91dCBkZXByZWNhdGlvblxuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gYW5jaG9yUG9pbnQgIT09IG51bGwgJiYgYW5jaG9yUG9pbnQgIT09IHZvaWQgMCA/IGFuY2hvclBvaW50IDogQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludFsnQk9UVE9NJ107XG4gICAgICAgICAgICAvLyBOT1RFOiBzaW5jZSB4IGFuZCB5IGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGxlbmd0aC1wZXJjZW50YWdlXG4gICAgICAgICAgICAvLyAgIHZhbHVlLCB3ZSBuZWVkIHRvIHVzZSBjYWxjKCkgdG8gbmVnYXRlIHRoZW0uXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVYID0gYGNhbGMoLTEgKiAke3h9KWA7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVZID0gYGNhbGMoLTEgKiAke3l9KWA7XG4gICAgICAgICAgICBpZiAoYW5jaG9yT3B0aW9uc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudCBhbmNob3JQb2ludCB1c2luZyB0aGUgbmV3IGFuY2hvckxlZnQgYW5kIGFuY2hvclRvcCBvcHRpb25zXG4gICAgICAgICAgICAgICAgbWFya2VyLmFuY2hvckxlZnQgPSB0cmFuc2xhdGVYO1xuICAgICAgICAgICAgICAgIG1hcmtlci5hbmNob3JUb3AgPSB0cmFuc2xhdGVZO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRyYW5zZm9ybSBmcm9tIGxlZ2FjeSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwidHJhbnNsYXRlKDUwJSwgMTAwJSlcIiBjb3VudGVycyBhbmQgcmVzZXRzIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yaW5nIG9mIHRoZSBhZHZhbmNlZCBtYXJrZXIgZWxlbWVudCBmcm9tIHRoZSBhcGlcbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKDUwJSwgMTAwJSkgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH0sICR7dHJhbnNsYXRlWX0pYDtcbiAgICAgICAgICAgICAgICAvLyBkYXRhLW9yaWdpbiBpcyBuZWVkZWQgdG8gaWRlbnRpZnkgdGhlIGN1c3RvbSBtYXJrZXIgY29udGVudCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBJbmZvV2luZG93IGNvbXBvbmVudCBhcyB3ZWxsIGFzIGluIHRoZSBnbG9iYWwgQ1NTIHVzZWQgdG8gZGlzYWJsZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBwb2ludGVyIGV2ZW50IHdoZW4gYW5jaG9yIHBvaW50cyBhcmUgdXNlZCBpbiBvbGRlciBHb29nbGUgTWFwc1xuICAgICAgICAgICAgICAgIC8vIHZlcnNpb25zLlxuICAgICAgICAgICAgICAgIG1hcmtlci5kYXRhc2V0Lm9yaWdpbiA9ICdyZ20nO1xuICAgICAgICAgICAgICAgIGdsb2JhbFN0eWxlTWFuYWdlci5hZGRBZHZhbmNlZE1hcmtlclBvaW50ZXJFdmVudHNPdmVyd3JpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXJrZXIsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AsIGhhc0NoaWxkcmVuXSk7XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKGVsZW1lbnQsIHN0eWxlcywgcHJldlN0eWxlcykge1xuICAgIGlmIChzdHlsZXMgIT0gbnVsbCAmJiB0eXBlb2Ygc3R5bGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArXG4gICAgICAgICAgICBcIm5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiBcIiArXG4gICAgICAgICAgICAndXNpbmcgSlNYLicpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIC8vIHdpdGhvdXQgYHByZXZTdHlsZXNgLCBqdXN0IHNldCBhbGwgdmFsdWVzXG4gICAgaWYgKHByZXZTdHlsZXMgPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3R5bGVzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUoZWxlbWVudFN0eWxlLCBzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVuc2V0IGFsbCBzdHlsZXMgaW4gYHByZXZTdHlsZXNgIHRoYXQgYXJlbid0IGluIGBzdHlsZXNgXG4gICAgZm9yIChjb25zdCBzdHlsZU5hbWUgaW4gcHJldlN0eWxlcykge1xuICAgICAgICBpZiAocHJldlN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAoc3R5bGVzID09IG51bGwgfHwgIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgc3R5bGVcbiAgICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgYXNzaWduIHZhbHVlcyBmcm9tIGBzdHlsZXNgIHRoYXQgYXJlIGRpZmZlcmVudCBmcm9tIGBwcmV2U3R5bGVzYFxuICAgIGlmIChzdHlsZXMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgIHByZXZTdHlsZXNbc3R5bGVOYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUoZWxlbWVudFN0eWxlLCBzdHlsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGUoZWxlbWVudFN0eWxlLCBzdHlsZU5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIC8vIGZhbHN5IHZhbHVlcyB3aWxsIHVuc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eVxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbid0IGJlIGRpcmVjdGx5IGFzc2lnbmVkXG4gICAgZWxzZSBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICBlbGVtZW50U3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIG51bWVyaWMgdmFsdWVzIGFyZSB0cmVhdGVkIGFzICdweCcgdW5sZXNzIHRoZSBzdHlsZSBwcm9wZXJ0eSBleHBlY3RzIHVuaXRsZXNzIG51bWJlcnNcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlICE9PSAwICYmXG4gICAgICAgICFpc1VuaXRsZXNzTnVtYmVyKHN0eWxlTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gICAgfVxuICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBjYW4ganVzdCBiZSBhc3NpZ25lZFxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGUuY3NzRmxvYXQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gKCcnICsgdmFsdWUpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbmNvbnN0IHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoW1xuICAgICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsXG4gICAgJ2FzcGVjdFJhdGlvJyxcbiAgICAnYm9yZGVySW1hZ2VPdXRzZXQnLFxuICAgICdib3JkZXJJbWFnZVNsaWNlJyxcbiAgICAnYm9yZGVySW1hZ2VXaWR0aCcsXG4gICAgJ2JveEZsZXgnLFxuICAgICdib3hGbGV4R3JvdXAnLFxuICAgICdib3hPcmRpbmFsR3JvdXAnLFxuICAgICdjb2x1bW5Db3VudCcsXG4gICAgJ2NvbHVtbnMnLFxuICAgICdmbGV4JyxcbiAgICAnZmxleEdyb3cnLFxuICAgICdmbGV4UG9zaXRpdmUnLFxuICAgICdmbGV4U2hyaW5rJyxcbiAgICAnZmxleE5lZ2F0aXZlJyxcbiAgICAnZmxleE9yZGVyJyxcbiAgICAnZ3JpZEFyZWEnLFxuICAgICdncmlkUm93JyxcbiAgICAnZ3JpZFJvd0VuZCcsXG4gICAgJ2dyaWRSb3dTcGFuJyxcbiAgICAnZ3JpZFJvd1N0YXJ0JyxcbiAgICAnZ3JpZENvbHVtbicsXG4gICAgJ2dyaWRDb2x1bW5FbmQnLFxuICAgICdncmlkQ29sdW1uU3BhbicsXG4gICAgJ2dyaWRDb2x1bW5TdGFydCcsXG4gICAgJ2ZvbnRXZWlnaHQnLFxuICAgICdsaW5lQ2xhbXAnLFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAnb3BhY2l0eScsXG4gICAgJ29yZGVyJyxcbiAgICAnb3JwaGFucycsXG4gICAgJ3NjYWxlJyxcbiAgICAndGFiU2l6ZScsXG4gICAgJ3dpZG93cycsXG4gICAgJ3pJbmRleCcsXG4gICAgJ3pvb20nLFxuICAgICdmaWxsT3BhY2l0eScsIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgICAnZmxvb2RPcGFjaXR5JyxcbiAgICAnc3RvcE9wYWNpdHknLFxuICAgICdzdHJva2VEYXNoYXJyYXknLFxuICAgICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgICAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICdzdHJva2VXaWR0aCdcbl0pO1xuZnVuY3Rpb24gaXNVbml0bGVzc051bWJlcihuYW1lKSB7XG4gICAgcmV0dXJuIHVuaXRsZXNzTnVtYmVycy5oYXMobmFtZSk7XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhbiBJbmZvIFdpbmRvdyB3aXRoIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJXG4gKi9cbmNvbnN0IEluZm9XaW5kb3cgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgeyBcbiAgICAvLyBjb250ZW50IG9wdGlvbnNcbiAgICBjaGlsZHJlbiwgaGVhZGVyQ29udGVudCwgc3R5bGUsIGNsYXNzTmFtZSwgcGl4ZWxPZmZzZXQsIFxuICAgIC8vIG9wZW4gb3B0aW9uc1xuICAgIGFuY2hvciwgc2hvdWxkRm9jdXMsIFxuICAgIC8vIGV2ZW50c1xuICAgIG9uQ2xvc2UsIG9uQ2xvc2VDbGljayB9ID0gcHJvcHMsIFxuICAgIC8vIG90aGVyIG9wdGlvbnNcbiAgICB2b2xhdGlsZUluZm9XaW5kb3dPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImhlYWRlckNvbnRlbnRcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcInBpeGVsT2Zmc2V0XCIsIFwiYW5jaG9yXCIsIFwic2hvdWxkRm9jdXNcIiwgXCJvbkNsb3NlXCIsIFwib25DbG9zZUNsaWNrXCJdKTtcbiAgICAvLyAjIyBjcmVhdGUgaW5mb3dpbmRvdyBpbnN0YW5jZSBvbmNlIHRoZSBtYXBzTGlicmFyeSBpcyBhdmFpbGFibGUuXG4gICAgY29uc3QgbWFwc0xpYnJhcnkgPSB1c2VNYXBzTGlicmFyeSgnbWFwcycpO1xuICAgIGNvbnN0IFtpbmZvV2luZG93LCBzZXRJbmZvV2luZG93XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaGVhZGVyQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGluZm9XaW5kb3dPcHRpb25zID0gdXNlTWVtb2l6ZWQodm9sYXRpbGVJbmZvV2luZG93T3B0aW9ucywgaXNEZWVwRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwc0xpYnJhcnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgIGlmIChwaXhlbE9mZnNldCkge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0WzBdLCBwaXhlbE9mZnNldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIGhlYWRlckNvbnRlbnQgaXMgc3BlY2lmaWVkIGFzIHN0cmluZyB3ZSBjYW4gZGlyZWN0bHkgZm9yd2FyZCBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSdsbCBwYXNzIHRoZSBlbGVtZW50IHRoZSBwb3J0YWwgd2lsbCByZW5kZXIgaW50b1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJDb250ZW50ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaGVhZGVyQ29udGVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBoZWFkZXJDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDogaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBzaGFkb3dpbmcgdGhlIHN0YXRlIHZhcmlhYmxlcyBoZXJlXG4gICAgICAgIGNvbnN0IGluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhpbmZvV2luZG93T3B0aW9ucyk7XG4gICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgICAgICBzZXRJbmZvV2luZG93KGluZm9XaW5kb3cpO1xuICAgICAgICAvLyB1bm1vdW50OiByZW1vdmUgaW5mb1dpbmRvdyBhbmQgY29udGVudCBlbGVtZW50cyAobm90ZTogY2xvc2UgaXMgY2FsbGVkIGluIGEgZGlmZmVyZW50IGVmZmVjdC1jbGVhbnVwKVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChudWxsKTtcbiAgICAgICAgICAgIChfYSA9IGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9iID0gaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBzZXRJbmZvV2luZG93KG51bGwpO1xuICAgICAgICB9O1xuICAgIH0sIFxuICAgIC8vIGBpbmZvV2luZG93T3B0aW9uc2AgYW5kIG90aGVyIHByb3BzIGFyZSBtaXNzaW5nIGZyb20gZGVwZW5kZW5jaWVzOlxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZS1jcmVhdGUgdGhlIGluZm93aW5kb3cgaW5zdGFuY2VcbiAgICAvLyB3aGVuIHRoZSBvcHRpb25zIGNoYW5nZS5cbiAgICAvLyBVcGRhdGluZyB0aGUgb3B0aW9ucyBpcyBoYW5kbGVkIGluIHRoZSB1c2VFZmZlY3QgYmVsb3cuXG4gICAgLy9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW21hcHNMaWJyYXJ5XSk7XG4gICAgLy8gLS0tLSB1cGRhdGUgY2xhc3NOYW1lIGFuZCBzdHlsZXMgZm9yIGBjb250ZW50Q29udGFpbmVyYFxuICAgIC8vIHByZXZTdHlsZVJlZiBzdG9yZXMgcHJldmlvdXNseSBhcHBsaWVkIHN0eWxlIHByb3BlcnRpZXMsIHNvIHRoZXkgY2FuIGJlXG4gICAgLy8gcmVtb3ZlZCB3aGVuIHVuc2V0XG4gICAgY29uc3QgcHJldlN0eWxlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaW5mb1dpbmRvdyB8fCAhY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRWYWx1ZUZvclN0eWxlcyhjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQsIHN0eWxlIHx8IG51bGwsIHByZXZTdHlsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgcHJldlN0eWxlUmVmLmN1cnJlbnQgPSBzdHlsZSB8fCBudWxsO1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9PSBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xhc3NOYW1lKVxuICAgICAgICAgICAgY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcbiAgICB9LCBbaW5mb1dpbmRvdywgY2xhc3NOYW1lLCBzdHlsZV0pO1xuICAgIC8vIC0tLS0gdXBkYXRlIG9wdGlvbnNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWluZm9XaW5kb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wdHMgPSBpbmZvV2luZG93T3B0aW9ucztcbiAgICAgICAgaWYgKCFwaXhlbE9mZnNldCkge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLnBpeGVsT2Zmc2V0ID0gbmV3IGdvb2dsZS5tYXBzLlNpemUocGl4ZWxPZmZzZXRbMF0sIHBpeGVsT2Zmc2V0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlckNvbnRlbnQgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBoZWFkZXJDb250ZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IGhlYWRlckNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgOiBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBpbmZvV2luZG93LnNldE9wdGlvbnMoaW5mb1dpbmRvd09wdGlvbnMpO1xuICAgIH0sIFxuICAgIC8vIGRlcGVuZGVuY3kgYGluZm9XaW5kb3dgIGlzbid0IG5lZWRlZCBzaW5jZSBvcHRpb25zIGFyZSBhbHNvIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciB3aGVuIGEgbmV3IGluZm9XaW5kb3cgaXMgY3JlYXRlZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2luZm9XaW5kb3dPcHRpb25zLCBwaXhlbE9mZnNldCwgaGVhZGVyQ29udGVudF0pO1xuICAgIC8vICMjIGJpbmQgZXZlbnQgaGFuZGxlcnNcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihpbmZvV2luZG93LCAnY2xvc2UnLCBvbkNsb3NlKTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihpbmZvV2luZG93LCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljayk7XG4gICAgLy8gLS0tLSBvcGVuIGluZm8gd2luZG93IHdoZW4gY29udGVudCBhbmQgbWFwIGFyZSBhdmFpbGFibGVcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGBhbmNob3IgPT09IG51bGxgIG1lYW5zIGFuIGFuY2hvciBpcyBkZWZpbmVkIGJ1dCBub3QgcmVhZHkgeWV0LlxuICAgICAgICBpZiAoIW1hcCB8fCAhaW5mb1dpbmRvdyB8fCBhbmNob3IgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzT3BlbmVkV2l0aEFuY2hvciA9ICEhYW5jaG9yO1xuICAgICAgICBjb25zdCBvcGVuT3B0aW9ucyA9IHsgbWFwIH07XG4gICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgIG9wZW5PcHRpb25zLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgICAgIC8vIE9ubHkgZG8gdGhlIGluZm93aW5kb3cgYWRqdXN0aW5nIHdoZW4gZGVhbGluZyB3aXRoIGFuIEFkdmFuY2VkTWFya2VyXG4gICAgICAgICAgICBpZiAoaXNBZHZhbmNlZE1hcmtlcihhbmNob3IpICYmIGFuY2hvci5jb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvckJjciA9IGFuY2hvciA9PT0gbnVsbCB8fCBhbmNob3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGUgYW5jaG9yIGhhcyBjdXN0b20gY29udGVudCB3aXRoIG91ciBvd25cbiAgICAgICAgICAgICAgICAvLyBkaXYgd3JhcHBlci4gSWYgbm90LCB0aGF0IG1lYW5zIHdlIGhhdmUgYSByZWd1bGFyIEFkdmFuY2VkTWFya2VyIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiwgb3IgYW4gQWR2YW5jZWRNYXJrZXIgdGhhdCB1c2VzIHRoZSBhbmNob3JMZWZ0L2FuY2hvclRvcCBwcm9wcy5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gYWRqdXN0IHRoZSBpbmZvd2luZG93IHNpbmNlIGl0IGlzIGFsbCBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSBHb29nbGUgTWFwcyBBUEkuXG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvckJjciAmJiBhbmNob3IuZGF0YXNldC5vcmlnaW4gPT09ICdyZ20nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBzYWZlbHkgdHlwZWNhc3QgaGVyZSBzaW5jZSB3ZSBjb250cm9sIHRoYXQgZWxlbWVudCBhbmQgd2Uga25vdyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGEgZGl2XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvckRvbUNvbnRlbnQgPSAoX2EgPSBhbmNob3IuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50QmNyID0gYW5jaG9yRG9tQ29udGVudCA9PT0gbnVsbCB8fCBhbmNob3JEb21Db250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNob3JEb21Db250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjZW50ZXIgaW5mb3dpbmRvdyBhYm92ZSBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WCA9IGNvbnRlbnRCY3IueCAtXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JCY3IueCArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29udGVudEJjci53aWR0aCAtIGFuY2hvckJjci53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRZID0gY29udGVudEJjci55IC0gYW5jaG9yQmNyLnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBpbmZvV2luZG93T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0ID8gcGl4ZWxPZmZzZXRbMF0gKyBhbmNob3JPZmZzZXRYIDogYW5jaG9yT2Zmc2V0WCwgcGl4ZWxPZmZzZXQgPyBwaXhlbE9mZnNldFsxXSArIGFuY2hvck9mZnNldFkgOiBhbmNob3JPZmZzZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRm9jdXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3Blbk9wdGlvbnMuc2hvdWxkRm9jdXMgPSBzaG91bGRGb2N1cztcbiAgICAgICAgfVxuICAgICAgICBpbmZvV2luZG93Lm9wZW4ob3Blbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogd2hlbiB0aGUgaW5mb3dpbmRvdyBoYXMgYW4gYW5jaG9yLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc2hvdyB1cCBhZ2FpbiB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gYW5jaG9yIHdhcyByZW1vdmVkIGZyb20gdGhlIG1hcCBiZWZvcmUgaW5mb1dpbmRvdy5jbG9zZSgpIGlzIGNhbGxlZCBidXQgdGhlIGl0IGdldHNcbiAgICAgICAgICAgIC8vIGFkZGVkIGJhY2sgdG8gdGhlIG1hcCBhZnRlciB0aGF0LlxuICAgICAgICAgICAgLy8gTW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL2lzc3VldHJhY2tlci5nb29nbGUuY29tL2lzc3Vlcy8zNDM3NTA4NDlcbiAgICAgICAgICAgIGlmIChpc09wZW5lZFdpdGhBbmNob3IpXG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXQoJ2FuY2hvcicsIG51bGwpO1xuICAgICAgICAgICAgaW5mb1dpbmRvdy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtpbmZvV2luZG93LCBhbmNob3IsIG1hcCwgc2hvdWxkRm9jdXMsIGluZm9XaW5kb3dPcHRpb25zLCBwaXhlbE9mZnNldF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCksXG4gICAgICAgIGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgICBjcmVhdGVQb3J0YWwoaGVhZGVyQ29udGVudCwgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQpKSk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBsb2NhdGlvbiBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHN1aXRhYmxlIGZvciBHb29nbGUgU3RhdGljIE1hcHMgQVBJLlxuICpcbiAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBmb3JtYXQsIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGggbGF0L2xuZyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbG9jYXRpb24gaW4gdGhlIGZvcm1hdCBcImxhdCxsbmdcIiBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgXCI0MC43MTQ3MjgsLTczLjk5ODY3MlwiXG4gKiBmb3JtYXRMb2NhdGlvbih7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmV0dXJucyBcIk5ldyBZb3JrLCBOWVwiXG4gKiBmb3JtYXRMb2NhdGlvbihcIk5ldyBZb3JrLCBOWVwiKVxuICovXG5mdW5jdGlvbiBmb3JtYXRMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgID8gbG9jYXRpb25cbiAgICAgICAgOiBgJHtsb2NhdGlvbi5sYXR9LCR7bG9jYXRpb24ubG5nfWA7XG59XG4vLyBVc2VkIGZvciByZW1vdmluZyB0aGUgbGVhZGluZyBwaXBlIGZyb20gdGhlIHBhcmFtIHN0cmluZ1xuZnVuY3Rpb24gZm9ybWF0UGFyYW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBBc3NlbWJsZXMgbWFya2VyIHBhcmFtZXRlcnMgZm9yIHN0YXRpYyBtYXBzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXkgb2YgbWFya2VycyBhbmQgZ3JvdXBzIHRoZW0gYnkgdGhlaXIgc3R5bGUgcHJvcGVydGllcy5cbiAqIEl0IHRoZW4gY3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBtYXJrZXJzLCBpbmNsdWRpbmcgdGhlaXIgc3R5bGVzIGFuZCBsb2NhdGlvbnMsXG4gKiB3aGljaCBjYW4gYmUgdXNlZCBhcyBwYXJhbWV0ZXJzIGZvciBzdGF0aWMgbWFwIEFQSXMuXG4gKlxuICogQHBhcmFtIHtTdGF0aWNNYXBzTWFya2VyW119IFttYXJrZXJzPVtdXSAtIEFuIGFycmF5IG9mIG1hcmtlcnMgdG8gYmUgcHJvY2Vzc2VkLiBFYWNoIG1hcmtlciBjYW4gaGF2ZSBwcm9wZXJ0aWVzIHN1Y2ggYXMgY29sb3IsIGxhYmVsLCBzaXplLCBzY2FsZSwgaWNvbiwgYW5jaG9yLCBhbmQgbG9jYXRpb24uXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHN0cmluZ3MsIGVhY2ggcmVwcmVzZW50aW5nIGEgZ3JvdXAgb2YgbWFya2VycyB3aXRoIHRoZWlyIHN0eWxlcyBhbmQgbG9jYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtYXJrZXJzID0gW1xuICogICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnQScsIHNpemU6ICdtaWQnLCBsb2NhdGlvbjogJzQwLjcxNDcyOCwtNzMuOTk4NjcyJyB9LFxuICogICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnQicsIHNpemU6ICdtaWQnLCBsb2NhdGlvbjogJzQwLjcxNDcyOCwtNzMuOTk4NjcyJyB9LFxuICogICB7IGljb246ICdodHRwOi8vZXhhbXBsZS5jb20vaWNvbi5wbmcnLCBsb2NhdGlvbjogeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0gfVxuICogXTtcbiAqIGNvbnN0IHBhcmFtcyA9IGFzc2VtYmxlTWFya2VyUGFyYW1zKG1hcmtlcnMpO1xuICogLy8gUGFyYW1zIHdpbGwgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIG1hcmtlciBwYXJhbWV0ZXJzXG4gKiBFeGFtcGxlIG91dHB1dDogW1xuICogICBcImNvbG9yOmJsdWV8bGFiZWw6QXxzaXplOm1pZHw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTQ3MjgsLTczLjk5ODY3MlwiLFxuICogICBcImNvbG9yOmJsdWV8bGFiZWw6QnxzaXplOm1pZHw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTQ3MjgsLTczLjk5ODY3MlwiLFxuICogICBcImljb246aHR0cDovL2V4YW1wbGUuY29tL2ljb24ucG5nfDQwLjcxNDcyOCwtNzMuOTk4NjcyXCJcbiAqIF1cbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVNYXJrZXJQYXJhbXMobWFya2VycyA9IFtdKSB7XG4gICAgY29uc3QgbWFya2VyUGFyYW1zID0gW107XG4gICAgLy8gR3JvdXAgbWFya2VycyBieSBzdHlsZVxuICAgIGNvbnN0IG1hcmtlcnNCeVN0eWxlID0gbWFya2VycyA9PT0gbnVsbCB8fCBtYXJrZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJzLnJlZHVjZSgoc3R5bGVzLCBtYXJrZXIpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2xvciA9ICdyZWQnLCBsYWJlbCwgc2l6ZSwgc2NhbGUsIGljb24sIGFuY2hvciB9ID0gbWFya2VyO1xuICAgICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgc3R5bGUga2V5IGJhc2VkIG9uIGVpdGhlciBpY29uIHByb3BlcnRpZXMgb3Igc3RhbmRhcmQgbWFya2VyIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgcmVsZXZhbnRQcm9wcyA9IGljb24gPyBbaWNvbiwgYW5jaG9yLCBzY2FsZV0gOiBbY29sb3IsIGxhYmVsLCBzaXplXTtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVsZXZhbnRQcm9wcy5maWx0ZXIoQm9vbGVhbikuam9pbignLScpO1xuICAgICAgICBzdHlsZXNba2V5XSA9IHN0eWxlc1trZXldIHx8IFtdO1xuICAgICAgICBzdHlsZXNba2V5XS5wdXNoKG1hcmtlcik7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSwge30pO1xuICAgIE9iamVjdC52YWx1ZXMobWFya2Vyc0J5U3R5bGUgIT09IG51bGwgJiYgbWFya2Vyc0J5U3R5bGUgIT09IHZvaWQgMCA/IG1hcmtlcnNCeVN0eWxlIDoge30pLmZvckVhY2gobWFya2VycyA9PiB7XG4gICAgICAgIGxldCBtYXJrZXJQYXJhbSA9ICcnO1xuICAgICAgICBjb25zdCB7IGljb24gfSA9IG1hcmtlcnNbMF07XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZXIgc3R5bGUgZnJvbSBmaXJzdCBtYXJrZXIgaW4gZ3JvdXAgc2luY2UgYWxsIG1hcmtlcnMgc2hhcmUgdGhlIHNhbWUgc3R5bGUuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1hcmtlcnNbMF0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBiYXNlZCBvbiB3aGV0aGVyIG1hcmtlciB1c2VzIGN1c3RvbSBpY29uXG4gICAgICAgICAgICBjb25zdCByZWxldmFudEtleXMgPSBpY29uXG4gICAgICAgICAgICAgICAgPyBbJ2ljb24nLCAnYW5jaG9yJywgJ3NjYWxlJ11cbiAgICAgICAgICAgICAgICA6IFsnY29sb3InLCAnbGFiZWwnLCAnc2l6ZSddO1xuICAgICAgICAgICAgaWYgKHJlbGV2YW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyUGFyYW0gKz0gYHwke2tleX06JHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIGxvY2F0aW9uIGNvb3JkaW5hdGVzIGZvciBlYWNoIG1hcmtlciBpbiB0aGUgc3R5bGUgZ3JvdXBcbiAgICAgICAgLy8gSGFuZGxlcyBib3RoIHN0cmluZyBsb2NhdGlvbnMgYW5kIGxhdC9sbmcgb2JqZWN0IGZvcm1hdHMuXG4gICAgICAgIGZvciAoY29uc3QgbWFya2VyIG9mIG1hcmtlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIG1hcmtlci5sb2NhdGlvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IG1hcmtlci5sb2NhdGlvblxuICAgICAgICAgICAgICAgIDogYCR7bWFya2VyLmxvY2F0aW9uLmxhdH0sJHttYXJrZXIubG9jYXRpb24ubG5nfWA7XG4gICAgICAgICAgICBtYXJrZXJQYXJhbSArPSBgfCR7bG9jYXRpb259YDtcbiAgICAgICAgfVxuICAgICAgICBtYXJrZXJQYXJhbXMucHVzaChtYXJrZXJQYXJhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmtlclBhcmFtcy5tYXAoZm9ybWF0UGFyYW0pO1xufVxuXG4vLyBTdHlsZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gcGF0aHMgaW4gdGhlIFN0YXRpYyBNYXBzIEFQSVxuY29uc3QgUEFUSF9TVFlMRV9LRVlTID0gWydjb2xvcicsICd3ZWlnaHQnLCAnZmlsbGNvbG9yJywgJ2dlb2Rlc2ljJ107XG4vKipcbiAqIEJ1aWxkcyB0aGUgc3R5bGUgcG9ydGlvbiBvZiBhIHBhdGggcGFyYW1ldGVyIHN0cmluZy5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggb2JqZWN0IGNvbnRhaW5pbmcgc3R5bGUgcHJvcGVydGllc1xuICogQHJldHVybnMgQSBzdHJpbmcgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzIGluIHRoZSBmb3JtYXQgXCJ8a2V5OnZhbHVlXCJcbiAqL1xuZnVuY3Rpb24gYnVpbGRTdHlsZVBhcmFtcyhwYXRoKSB7XG4gICAgbGV0IHN0eWxlUGFyYW1zID0gJyc7XG4gICAgUEFUSF9TVFlMRV9LRVlTLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHBhdGhba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHlsZVBhcmFtcyArPSBgfCR7a2V5fToke3BhdGhba2V5XX1gO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlUGFyYW1zO1xufVxuLyoqXG4gKiBCdWlsZHMgdGhlIGNvb3JkaW5hdGVzIHBvcnRpb24gb2YgYSBwYXRoIHBhcmFtZXRlciBzdHJpbmcuXG4gKiBAcGFyYW0gY29vcmRpbmF0ZXMgLSBFaXRoZXIgYSBzdHJpbmcgb3IgYXJyYXkgb2YgbG9jYXRpb24gb2JqZWN0c1xuICogQHJldHVybnMgQSBzdHJpbmcgd2l0aCBjb29yZGluYXRlcyBpbiB0aGUgZm9ybWF0IFwifGxhdCxsbmd8bGF0LGxuZ1wiXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ29vcmRpbmF0ZVBhcmFtcyhjb29yZGluYXRlcykge1xuICAgIGlmICh0eXBlb2YgY29vcmRpbmF0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgfCR7ZGVjb2RlVVJJQ29tcG9uZW50KGNvb3JkaW5hdGVzKX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXMubWFwKGxvY2F0aW9uID0+IGB8JHtmb3JtYXRMb2NhdGlvbihsb2NhdGlvbil9YCkuam9pbignJyk7XG59XG4vKipcbiAqIEFzc2VtYmxlcyBwYXRoIHBhcmFtZXRlcnMgZm9yIHRoZSBTdGF0aWMgTWFwcyBBUEkgZnJvbSBhbiBhcnJheSBvZiBwYXRocy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnN0cnVjdHMgYSBzdHJpbmcgb2YgcGF0aCBwYXJhbWV0ZXJzIGZvciBlYWNoIHBhdGguIEVhY2ggcGF0aCBwYXJhbWV0ZXIgc3RyaW5nXG4gKiBpbmNsdWRlcyB0aGUgc3R5bGUgcHJvcGVydGllcyBhbmQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXRocy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFN0YXRpY01hcHNQYXRoPn0gW3BhdGhzPVtdXSAtIEFuIGFycmF5IG9mIHBhdGhzIHRvIGJlIGFzc2VtYmxlZCBpbnRvIHBhdGggcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBbiBhcnJheSBvZiBwYXRoIHBhcmFtZXRlciBzdHJpbmdzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwYXRocyA9IFtcbiAqICAge1xuICogICAgIGNvbG9yOiAncmVkJyxcbiAqICAgICB3ZWlnaHQ6IDUsXG4gKiAgICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgIHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICAgICAgeyBsYXQ6IDQwLjcxODIxNywgbG5nOiAtNzMuOTk4Mjg0IH1cbiAqICAgICBdXG4gKiAgIH1cbiAqIF07XG4gKlxuICogY29uc3QgcGF0aFBhcmFtcyA9IGFzc2VtYmxlUGF0aFBhcmFtcyhwYXRocyk7XG4gKiAvLyBPdXRwdXQ6IFsnY29sb3I6cmVkfHdlaWdodDo1fDQwLjcxNDcyOCwtNzMuOTk4NjcyfDQwLjcxODIxNywtNzMuOTk4Mjg0J11cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMgPSBbXSkge1xuICAgIHJldHVybiBwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlUGFyYW1zID0gYnVpbGRTdHlsZVBhcmFtcyhwYXRoKTtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZVBhcmFtcyA9IGJ1aWxkQ29vcmRpbmF0ZVBhcmFtcyhwYXRoLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgY29uc3QgcGF0aFBhcmFtID0gc3R5bGVQYXJhbXMgKyBjb29yZGluYXRlUGFyYW1zO1xuICAgICAgICByZXR1cm4gZm9ybWF0UGFyYW0ocGF0aFBhcmFtKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBHb29nbGUgTWFwcyBzdHlsZSBvYmplY3RzIGludG8gYW4gYXJyYXkgb2Ygc3R5bGUgc3RyaW5nc1xuICogY29tcGF0aWJsZSB3aXRoIHRoZSBHb29nbGUgU3RhdGljIE1hcHMgQVBJLlxuICpcbiAqIEBwYXJhbSBzdHlsZXMgLSBBbiBhcnJheSBvZiBHb29nbGUgTWFwcyBNYXBUeXBlU3R5bGUgb2JqZWN0cyB0aGF0IGRlZmluZSB0aGUgc3R5bGluZyBydWxlc1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgZm9ybWF0dGVkIHN0eWxlIHN0cmluZ3MgcmVhZHkgdG8gYmUgdXNlZCB3aXRoIHRoZSBTdGF0aWMgTWFwcyBBUElcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc3R5bGVzID0gW3tcbiAqICAgZmVhdHVyZVR5cGU6IFwicm9hZFwiLFxuICogICBlbGVtZW50VHlwZTogXCJnZW9tZXRyeVwiLFxuICogICBzdHlsZXJzOiBbe2NvbG9yOiBcIiNmZjAwMDBcIn0sIHt3ZWlnaHQ6IDF9XVxuICogfV07XG4gKlxuICogY29uc3Qgc3R5bGVTdHJpbmdzID0gYXNzZW1ibGVNYXBUeXBlU3R5bGVzKHN0eWxlcyk7XG4gKiAvLyBSZXR1cm5zOiBbXCJ8ZmVhdHVyZTpyb2FkfGVsZW1lbnQ6Z2VvbWV0cnl8Y29sb3I6MHhmZjAwMDB8d2VpZ2h0OjFcIl1cbiAqXG4gKiBFYWNoIHN0eWxlIHN0cmluZyBmb2xsb3dzIHRoZSBmb3JtYXQ6XG4gKiBcImZlYXR1cmU6e2ZlYXR1cmVUeXBlfXxlbGVtZW50OntlbGVtZW50VHlwZX18e3N0eWxlck5hbWV9OntzdHlsZXJWYWx1ZX1cIlxuICpcbiAqIE5vdGU6IENvbG9yIHZhbHVlcyB3aXRoIGhleGFkZWNpbWFsIG5vdGF0aW9uICgjKSBhcmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWRcbiAqIHRvIHRoZSByZXF1aXJlZCAweCBmb3JtYXQgZm9yIHRoZSBTdGF0aWMgTWFwcyBBUEkuXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZXMpIHtcbiAgICByZXR1cm4gc3R5bGVzXG4gICAgICAgIC5tYXAoKG1hcFR5cGVTdHlsZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGZlYXR1cmVUeXBlLCBlbGVtZW50VHlwZSwgc3R5bGVycyA9IFtdIH0gPSBtYXBUeXBlU3R5bGU7XG4gICAgICAgIGxldCBzdHlsZVN0cmluZyA9ICcnO1xuICAgICAgICBpZiAoZmVhdHVyZVR5cGUpIHtcbiAgICAgICAgICAgIHN0eWxlU3RyaW5nICs9IGB8ZmVhdHVyZToke2ZlYXR1cmVUeXBlfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfGVsZW1lbnQ6JHtlbGVtZW50VHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGVyIG9mIHN0eWxlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlcikuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0eWxlU3RyaW5nICs9IGB8JHtuYW1lfToke1N0cmluZyh2YWx1ZSkucmVwbGFjZSgnIycsICcweCcpfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVTdHJpbmc7XG4gICAgfSlcbiAgICAgICAgLm1hcChmb3JtYXRQYXJhbSk7XG59XG5cbmNvbnN0IFNUQVRJQ19NQVBTX0JBU0UgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcCc7XG4vKipcbiAqIENyZWF0ZXMgYSBVUkwgZm9yIHRoZSBHb29nbGUgU3RhdGljIE1hcHMgQVBJIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHN0YXRpYyBtYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFwaUtleSAtIFlvdXIgR29vZ2xlIE1hcHMgQVBJIGtleSAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbWFwIGltYWdlIGluIHBpeGVscyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBtYXAgaW1hZ2UgaW4gcGl4ZWxzIChyZXF1aXJlZClcbiAqIEBwYXJhbSB7U3RhdGljTWFwc0xvY2F0aW9ufSBbb3B0aW9ucy5jZW50ZXJdIC0gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgbWFwIChsYXQvbG5nIG9yIGFkZHJlc3MpLlxuICogIFJlcXVpcmVkIGlmIG5vIG1hcmtlcnMgb3IgcGF0aHMgb3IgXCJ2aXNpYmxlIGxvY2F0aW9uc1wiIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy56b29tXSAtIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFJlcXVpcmVkIGlmIG5vIG1hcmtlcnMgb3IgcGF0aHMgb3IgXCJ2aXNpYmxlIGxvY2F0aW9uc1wiIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7MXwyfDR9IFtvcHRpb25zLnNjYWxlXSAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBtYXAgKDEsIDIsIG9yIDQpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSAtIFRoZSBpbWFnZSBmb3JtYXQgKHBuZywgcG5nOCwgcG5nMzIsIGdpZiwganBnLCBqcGctYmFzZWxpbmUpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFwVHlwZV0gLSBUaGUgdHlwZSBvZiBtYXAgKHJvYWRtYXAsIHNhdGVsbGl0ZSwgdGVycmFpbiwgaHlicmlkKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXSAtIFRoZSBsYW5ndWFnZSBvZiB0aGUgbWFwIGxhYmVsc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlZ2lvbl0gLSBUaGUgcmVnaW9uIGNvZGUgZm9yIHRoZSBtYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXBfaWRdIC0gVGhlIENsb3VkLWJhc2VkIG1hcCBzdHlsZSBJRFxuICogQHBhcmFtIHtTdGF0aWNNYXBzTWFya2VyW119IFtvcHRpb25zLm1hcmtlcnM9W11dIC0gQXJyYXkgb2YgbWFya2VycyB0byBkaXNwbGF5IG9uIHRoZSBtYXBcbiAqIEBwYXJhbSB7U3RhdGljTWFwc1BhdGhbXX0gW29wdGlvbnMucGF0aHM9W11dIC0gQXJyYXkgb2YgcGF0aHMgdG8gZGlzcGxheSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNMb2NhdGlvbltdfSBbb3B0aW9ucy52aXNpYmxlPVtdXSAtIEFycmF5IG9mIGxvY2F0aW9ucyB0aGF0IHNob3VsZCBiZSB2aXNpYmxlIG9uIHRoZSBtYXBcbiAqIEBwYXJhbSB7TWFwVHlwZVN0eWxlW119IFtvcHRpb25zLnN0eWxlPVtdXSAtIEFycmF5IG9mIHN0eWxlIG9iamVjdHMgdG8gY3VzdG9taXplIHRoZSBtYXAgYXBwZWFyYW5jZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21wbGV0ZSBHb29nbGUgU3RhdGljIE1hcHMgQVBJIFVSTFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBBUEkga2V5IGlzIG5vdCBwcm92aWRlZFxuICogQHRocm93cyB7RXJyb3J9IElmIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcHJvdmlkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdXJsID0gY3JlYXRlU3RhdGljTWFwc1VybCh7XG4gKiAgIGFwaUtleTogJ1lPVVJfQVBJX0tFWScsXG4gKiAgIHdpZHRoOiA2MDAsXG4gKiAgIGhlaWdodDogNDAwLFxuICogICBjZW50ZXI6IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICB6b29tOiAxMixcbiAqICAgbWFya2VyczogW1xuICogICAgIHtcbiAqICAgICAgIGxvY2F0aW9uOiB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgICAgIGNvbG9yOiAncmVkJyxcbiAqICAgICAgIGxhYmVsOiAnQSdcbiAqICAgICB9XG4gKiAgIF0sXG4gKiAgIHBhdGhzOiBbXG4gKiAgICAge1xuICogICAgICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICAgeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgICAgICAgIHsgbGF0OiA0MC43MTk3MjgsIGxuZzogLTczLjk5MTY3MiB9XG4gKiAgICAgICBdLFxuICogICAgICAgY29sb3I6ICcweDAwMDBmZicsXG4gKiAgICAgICB3ZWlnaHQ6IDVcbiAqICAgICB9XG4gKiAgIF0sXG4gKiAgIHN0eWxlOiBbXG4gKiAgICAge1xuICogICAgICAgZmVhdHVyZVR5cGU6ICdyb2FkJyxcbiAqICAgICAgIGVsZW1lbnRUeXBlOiAnZ2VvbWV0cnknLFxuICogICAgICAgc3R5bGVyczogW3tjb2xvcjogJyMwMGZmMDAnfV1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gVVJMIHNpbWlsYXIgdG86XG4gKiAvLyBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvc3RhdGljbWFwP2tleT1ZT1VSX0FQSV9LRVlcbiAqIC8vICZzaXplPTYwMHg0MDBcbiAqIC8vICZjZW50ZXI9NDAuNzE0NzI4LC03My45OTg2NzImem9vbT0xMlxuICogLy8gJm1hcmtlcnM9Y29sb3I6cmVkfGxhYmVsOkF8NDAuNzE0NzI4LC03My45OTg2NzJcbiAqIC8vICZwYXRoPWNvbG9yOjB4MDAwMGZmfHdlaWdodDo1fDQwLjcxNDcyOCwtNzMuOTk4NjcyfDQwLjcxOTcyOCwtNzMuOTkxNjcyXG4gKiAvLyAmc3R5bGU9ZmVhdHVyZTpyb2FkfGVsZW1lbnQ6Z2VvbWV0cnl8Y29sb3I6MHgwMGZmMDBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljTWFwc1VybCh7IGFwaUtleSwgd2lkdGgsIGhlaWdodCwgY2VudGVyLCB6b29tLCBzY2FsZSwgZm9ybWF0LCBtYXBUeXBlLCBsYW5ndWFnZSwgcmVnaW9uLCBtYXBJZCwgbWFya2VycyA9IFtdLCBwYXRocyA9IFtdLCB2aXNpYmxlID0gW10sIHN0eWxlID0gW10gfSkge1xuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQVBJIGtleSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXaWR0aCBhbmQgaGVpZ2h0IGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBrZXk6IGFwaUtleSwgc2l6ZTogYCR7d2lkdGh9eCR7aGVpZ2h0fWAgfSwgKGNlbnRlciAmJiB7IGNlbnRlcjogZm9ybWF0TG9jYXRpb24oY2VudGVyKSB9KSksICh6b29tICYmIHsgem9vbSB9KSksIChzY2FsZSAmJiB7IHNjYWxlIH0pKSwgKGZvcm1hdCAmJiB7IGZvcm1hdCB9KSksIChtYXBUeXBlICYmIHsgbWFwdHlwZTogbWFwVHlwZSB9KSksIChsYW5ndWFnZSAmJiB7IGxhbmd1YWdlIH0pKSwgKHJlZ2lvbiAmJiB7IHJlZ2lvbiB9KSksIChtYXBJZCAmJiB7IG1hcF9pZDogbWFwSWQgfSkpO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoU1RBVElDX01BUFNfQkFTRSk7XG4gICAgLy8gUGFyYW1zIHRoYXQgZG9uJ3QgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICB9KTtcbiAgICAvLyBBc3NlbWJsZSBNYXJrZXJzXG4gICAgZm9yIChjb25zdCBtYXJrZXJQYXJhbSBvZiBhc3NlbWJsZU1hcmtlclBhcmFtcyhtYXJrZXJzKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbWFya2VycycsIG1hcmtlclBhcmFtKTtcbiAgICB9XG4gICAgLy8gQXNzZW1ibGUgUGF0aHNcbiAgICBmb3IgKGNvbnN0IHBhdGhQYXJhbSBvZiBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMpKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdwYXRoJywgcGF0aFBhcmFtKTtcbiAgICB9XG4gICAgLy8gQXNzZW1ibGUgdmlzaWJsZSBsb2NhdGlvbnNcbiAgICBpZiAodmlzaWJsZS5sZW5ndGgpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3Zpc2libGUnLCB2aXNpYmxlLm1hcChsb2NhdGlvbiA9PiBmb3JtYXRMb2NhdGlvbihsb2NhdGlvbikpLmpvaW4oJ3wnKSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIE1hcCBUeXBlIFN0eWxlc1xuICAgIGZvciAoY29uc3Qgc3R5bGVTdHJpbmcgb2YgYXNzZW1ibGVNYXBUeXBlU3R5bGVzKHN0eWxlKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3R5bGUnLCBzdHlsZVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuY29uc3QgU3RhdGljTWFwID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB1cmwsIGNsYXNzTmFtZSB9ID0gcHJvcHM7XG4gICAgaWYgKCF1cmwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIGlzIHJlcXVpcmVkJyk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3JjOiB1cmwsIHdpZHRoOiBcIjEwMCVcIiB9KTtcbn07XG5cbi8qKlxuICogQ29weSBvZiB0aGUgYGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb250cm9sUG9zaXRpb24gPSB7XG4gICAgVE9QX0xFRlQ6IDEsXG4gICAgVE9QX0NFTlRFUjogMixcbiAgICBUT1A6IDIsXG4gICAgVE9QX1JJR0hUOiAzLFxuICAgIExFRlRfQ0VOVEVSOiA0LFxuICAgIExFRlRfVE9QOiA1LFxuICAgIExFRlQ6IDUsXG4gICAgTEVGVF9CT1RUT006IDYsXG4gICAgUklHSFRfVE9QOiA3LFxuICAgIFJJR0hUOiA3LFxuICAgIFJJR0hUX0NFTlRFUjogOCxcbiAgICBSSUdIVF9CT1RUT006IDksXG4gICAgQk9UVE9NX0xFRlQ6IDEwLFxuICAgIEJPVFRPTV9DRU5URVI6IDExLFxuICAgIEJPVFRPTTogMTEsXG4gICAgQk9UVE9NX1JJR0hUOiAxMixcbiAgICBDRU5URVI6IDEzLFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9TVEFSVDogMTQsXG4gICAgQkxPQ0tfU1RBUlRfSU5MSU5FX0NFTlRFUjogMTUsXG4gICAgQkxPQ0tfU1RBUlRfSU5MSU5FX0VORDogMTYsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX0NFTlRFUjogMTcsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX1NUQVJUOiAxOCxcbiAgICBJTkxJTkVfU1RBUlRfQkxPQ0tfRU5EOiAxOSxcbiAgICBJTkxJTkVfRU5EX0JMT0NLX1NUQVJUOiAyMCxcbiAgICBJTkxJTkVfRU5EX0JMT0NLX0NFTlRFUjogMjEsXG4gICAgSU5MSU5FX0VORF9CTE9DS19FTkQ6IDIyLFxuICAgIEJMT0NLX0VORF9JTkxJTkVfU1RBUlQ6IDIzLFxuICAgIEJMT0NLX0VORF9JTkxJTkVfQ0VOVEVSOiAyNCxcbiAgICBCTE9DS19FTkRfSU5MSU5FX0VORDogMjVcbn07XG5jb25zdCBNYXBDb250cm9sID0gKHsgY2hpbGRyZW4sIHBvc2l0aW9uIH0pID0+IHtcbiAgICBjb25zdCBjb250cm9sQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb250cm9scyA9IG1hcC5jb250cm9sc1twb3NpdGlvbl07XG4gICAgICAgIGNvbnRyb2xzLnB1c2goY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sc0FycmF5ID0gY29udHJvbHMuZ2V0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIGNvbnRyb2xzQXJyYXkgY291bGQgYmUgdW5kZWZpbmVkIGlmIHRoZSBtYXAgaXMgaW4gYW4gdW5kZWZpbmVkIHN0YXRlIChlLmcuIGludmFsaWQgQVBJLWtleSwgc2VlICMyNzZcbiAgICAgICAgICAgIGlmICghY29udHJvbHNBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRyb2xzQXJyYXkuaW5kZXhPZihjb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRyb2xzLnJlbW92ZUF0KGluZGV4KTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29udHJvbENvbnRhaW5lciwgbWFwLCBwb3NpdGlvbl0pO1xuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRyb2xDb250YWluZXIpO1xufTtcblxuZnVuY3Rpb24gdXNlTWFya2VyKHByb3BzKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIGNvbnN0IHsgb25DbGljaywgb25EcmFnLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBvbk1vdXNlT3Zlciwgb25Nb3VzZU91dCB9ID0gcHJvcHMsIG1hcmtlck9wdGlvbnMgPSBfX3Jlc3QocHJvcHMsIFtcIm9uQ2xpY2tcIiwgXCJvbkRyYWdcIiwgXCJvbkRyYWdTdGFydFwiLCBcIm9uRHJhZ0VuZFwiLCBcIm9uTW91c2VPdmVyXCIsIFwib25Nb3VzZU91dFwiXSk7XG4gICAgY29uc3QgeyBwb3NpdGlvbiwgZHJhZ2dhYmxlIH0gPSBtYXJrZXJPcHRpb25zO1xuICAgIC8vIGNyZWF0ZSBtYXJrZXIgaW5zdGFuY2UgYW5kIGFkZCB0byB0aGUgbWFwIG9uY2UgdGhlIG1hcCBpcyBhdmFpbGFibGVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgaWYgKG1hcCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJzxNYXJrZXI+IGhhcyB0byBiZSBpbnNpZGUgYSBNYXAgY29tcG9uZW50LicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobWFya2VyT3B0aW9ucyk7XG4gICAgICAgIG5ld01hcmtlci5zZXRNYXAobWFwKTtcbiAgICAgICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdNYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgc2V0TWFya2VyKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZS1yZW5kZXIgdGhlIHdob2xlIG1hcmtlciB3aGVuIHRoZSBvcHRpb25zIGNoYW5nZS5cbiAgICAgICAgLy8gTWFya2VyIG9wdGlvbnMgdXBkYXRlIGlzIGhhbmRsZWQgaW4gYSB1c2VFZmZlY3QgYmVsb3cuXG4gICAgICAgIC8vIEV4Y2x1ZGluZyBtYXJrZXJPcHRpb25zIGZyb20gZGVwZW5kZW5jeSBhcnJheSBvbiBwdXJwb3NlIGhlcmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbbWFwXSk7XG4gICAgLy8gYXR0YWNoIGFuZCByZS1hdHRhY2ggZXZlbnQtaGFuZGxlcnMgd2hlbiBhbnkgb2YgdGhlIHByb3BlcnRpZXMgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG0gPSBtYXJrZXI7XG4gICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgICAgIGlmIChvbkNsaWNrKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgICBpZiAob25EcmFnKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnJywgb25EcmFnKTtcbiAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgICAgIGlmIChvbkRyYWdFbmQpXG4gICAgICAgICAgICBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgICAgICBpZiAob25Nb3VzZU92ZXIpXG4gICAgICAgICAgICBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKTtcbiAgICAgICAgaWYgKG9uTW91c2VPdXQpXG4gICAgICAgICAgICBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCk7XG4gICAgICAgIG1hcmtlci5zZXREcmFnZ2FibGUoQm9vbGVhbihkcmFnZ2FibGUpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGdtZS5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgbWFya2VyLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIG9uQ2xpY2ssXG4gICAgICAgIG9uRHJhZyxcbiAgICAgICAgb25EcmFnU3RhcnQsXG4gICAgICAgIG9uRHJhZ0VuZCxcbiAgICAgICAgb25Nb3VzZU92ZXIsXG4gICAgICAgIG9uTW91c2VPdXRcbiAgICBdKTtcbiAgICAvLyB1cGRhdGUgbWFya2VyT3B0aW9ucyAobm90ZSB0aGUgZGVwZW5kZW5jaWVzIGFyZW4ndCBwcm9wZXJseSBjaGVja2VkXG4gICAgLy8gaGVyZSwgd2UganVzdCBhc3N1bWUgdGhhdCBzZXRPcHRpb25zIGlzIHNtYXJ0IGVub3VnaCB0byBub3Qgd2FzdGUgYVxuICAgIC8vIGxvdCBvZiB0aW1lIHVwZGF0aW5nIHZhbHVlcyB0aGF0IGRpZG4ndCBjaGFuZ2UpXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zKVxuICAgICAgICAgICAgbWFya2VyLnNldE9wdGlvbnMobWFya2VyT3B0aW9ucyk7XG4gICAgfSwgW21hcmtlciwgbWFya2VyT3B0aW9uc10pO1xuICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiB3aGVuIGNoYW5nZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBTaG91bGQgbm90IHVwZGF0ZSBwb3NpdGlvbiB3aGVuIGRyYWdnYWJsZVxuICAgICAgICBpZiAoZHJhZ2dhYmxlIHx8ICFwb3NpdGlvbiB8fCAhbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYXJrZXIuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH0sIFtkcmFnZ2FibGUsIHBvc2l0aW9uLCBtYXJrZXJdKTtcbiAgICByZXR1cm4gbWFya2VyO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gcmVuZGVyIGEgbWFya2VyIG9uIGEgbWFwXG4gKi9cbmNvbnN0IE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCBtYXJrZXIgPSB1c2VNYXJrZXIocHJvcHMpO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBtYXJrZXIsIFttYXJrZXJdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCk7XG59KTtcbk1hcmtlci5kaXNwbGF5TmFtZSA9ICdNYXJrZXInO1xuZnVuY3Rpb24gdXNlTWFya2VyUmVmKCkge1xuICAgIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCByZWZDYWxsYmFjayA9IHVzZUNhbGxiYWNrKChtKSA9PiB7XG4gICAgICAgIHNldE1hcmtlcihtKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtyZWZDYWxsYmFjaywgbWFya2VyXTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgdG8gY29uZmlndXJlIHRoZSBhcHBlYXJhbmNlIG9mIGFuIEFkdmFuY2VkTWFya2VyXG4gKi9cbmNvbnN0IFBpbiA9IHByb3BzID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWR2YW5jZWRNYXJrZXIgPSAoX2EgPSB1c2VDb250ZXh0KEFkdmFuY2VkTWFya2VyQ29udGV4dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXI7XG4gICAgY29uc3QgZ2x5cGhDb250YWluZXIgPSB1c2VNZW1vKCgpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBbXSk7XG4gICAgLy8gQ3JlYXRlIFBpbiBWaWV3IGluc3RhbmNlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWFkdmFuY2VkTWFya2VyKSB7XG4gICAgICAgICAgICBpZiAoYWR2YW5jZWRNYXJrZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSA8UGluPiBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgPEFkdmFuY2VkTWFya2VyPi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuZ2x5cGggJiYgcHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yT25jZSgnVGhlIDxQaW4+IGNvbXBvbmVudCBvbmx5IHVzZXMgY2hpbGRyZW4gdG8gcmVuZGVyIHRoZSBnbHlwaCBpZiBib3RoIHRoZSBnbHlwaCBwcm9wZXJ0eSBhbmQgY2hpbGRyZW4gYXJlIHByZXNlbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDEpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yT25jZSgnUGFzc2luZyBtdWx0aXBsZSBjaGlsZHJlbiB0byB0aGUgPFBpbj4gY29tcG9uZW50IG1pZ2h0IGxlYWQgdG8gdW5leHBlY3RlZCByZXN1bHRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpblZpZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpO1xuICAgICAgICBjb25zdCBwaW5FbGVtZW50ID0gbmV3IGdvb2dsZS5tYXBzLm1hcmtlci5QaW5FbGVtZW50KHBpblZpZXdPcHRpb25zKTtcbiAgICAgICAgLy8gU2V0IGdseXBoIHRvIGdseXBoIGNvbnRhaW5lciBpZiBjaGlsZHJlbiBhcmUgcHJlc2VudCAocmVuZGVyZWQgdmlhIHBvcnRhbCkuXG4gICAgICAgIC8vIElmIGJvdGggcHJvcHMuZ2x5cGggYW5kIHByb3BzLmNoaWxkcmVuIGFyZSBwcmVzZW50LCBwcm9wcy5jaGlsZHJlbiB0YWtlcyBwcmlvcml0eS5cbiAgICAgICAgaWYgKHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwaW5FbGVtZW50LmdseXBoID0gZ2x5cGhDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGNvbnRlbnQgb2YgQWR2YW5jZWQgTWFya2VyIFZpZXcgdG8gdGhlIFBpbiBWaWV3IGVsZW1lbnRcbiAgICAgICAgLy8gSGVyZSB3ZSBhcmUgc2VsZWN0aW5nIHRoZSBhbmNob3IgY29udGFpbmVyLlxuICAgICAgICAvLyBUaGUgaGllcmFyY2h5IGlzIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vIFwiYWR2YW5jZWRNYXJrZXIuY29udGVudFwiIChmcm9tIGdvb2dsZSkgLT4gXCJhbmNob3IgY29udGFpbmVyXCJcbiAgICAgICAgY29uc3QgbWFya2VyQ29udGVudCA9IChfYSA9IGFkdmFuY2VkTWFya2VyLmNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAobWFya2VyQ29udGVudCA9PT0gbnVsbCB8fCBtYXJrZXJDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJDb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmtlckNvbnRlbnQucmVtb3ZlQ2hpbGQobWFya2VyQ29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyQ29udGVudCkge1xuICAgICAgICAgICAgbWFya2VyQ29udGVudC5hcHBlbmRDaGlsZChwaW5FbGVtZW50LmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSwgW2FkdmFuY2VkTWFya2VyLCBnbHlwaENvbnRhaW5lciwgcHJvcHNdKTtcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKHByb3BzLmNoaWxkcmVuLCBnbHlwaENvbnRhaW5lcik7XG59O1xuXG5jb25zdCBtYXBMaW5lYXIgPSAoeCwgYTEsIGEyLCBiMSwgYjIpID0+IGIxICsgKCh4IC0gYTEpICogKGIyIC0gYjEpKSAvIChhMiAtIGExKTtcbmNvbnN0IGdldE1hcE1heFRpbHQgPSAoem9vbSkgPT4ge1xuICAgIGlmICh6b29tIDw9IDEwKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9XG4gICAgaWYgKHpvb20gPj0gMTUuNSkge1xuICAgICAgICByZXR1cm4gNjcuNTtcbiAgICB9XG4gICAgLy8gcmFuZ2UgWzEwLi4uMTRdXG4gICAgaWYgKHpvb20gPD0gMTQpIHtcbiAgICAgICAgcmV0dXJuIG1hcExpbmVhcih6b29tLCAxMCwgMTQsIDMwLCA0NSk7XG4gICAgfVxuICAgIC8vIHJhbmdlIFsxNC4uLjE1LjVdXG4gICAgcmV0dXJuIG1hcExpbmVhcih6b29tLCAxNCwgMTUuNSwgNDUsIDY3LjUpO1xufTtcbi8qKlxuICogRnVuY3Rpb24gdG8gbGltaXQgdGhlIHRpbHQgcmFuZ2Ugb2YgdGhlIEdvb2dsZSBtYXAgd2hlbiB1cGRhdGluZyB0aGUgdmlldyBzdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbGltaXRUaWx0UmFuZ2UgPSAoeyB2aWV3U3RhdGUgfSkgPT4ge1xuICAgIGNvbnN0IHBpdGNoID0gdmlld1N0YXRlLnBpdGNoO1xuICAgIGNvbnN0IGdtWm9vbSA9IHZpZXdTdGF0ZS56b29tICsgMTtcbiAgICBjb25zdCBtYXhUaWx0ID0gZ2V0TWFwTWF4VGlsdChnbVpvb20pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZXdTdGF0ZSksIHsgZm92eTogMjUsIHBpdGNoOiBNYXRoLm1pbihtYXhUaWx0LCBwaXRjaCkgfSk7XG59O1xuXG5leHBvcnQgeyBBUElMb2FkaW5nU3RhdHVzLCBBUElQcm92aWRlciwgQVBJUHJvdmlkZXJDb250ZXh0LCBBZHZhbmNlZE1hcmtlciwgQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludCwgQWR2YW5jZWRNYXJrZXJDb250ZXh0LCBDb2xsaXNpb25CZWhhdmlvciwgQ29sb3JTY2hlbWUsIENvbnRyb2xQb3NpdGlvbiwgR29vZ2xlTWFwc0NvbnRleHQsIEluZm9XaW5kb3csIE1hcCwgTWFwQ29udHJvbCwgTWFya2VyLCBQaW4sIFJlbmRlcmluZ1R5cGUsIFN0YXRpY01hcCwgVkVSU0lPTiwgY3JlYXRlU3RhdGljTWFwc1VybCwgaXNBZHZhbmNlZE1hcmtlciwgaXNMYXRMbmdMaXRlcmFsLCBsYXRMbmdFcXVhbHMsIGxpbWl0VGlsdFJhbmdlLCB0b0xhdExuZ0xpdGVyYWwsIHVzZUFkdmFuY2VkTWFya2VyUmVmLCB1c2VBcGlJc0xvYWRlZCwgdXNlQXBpTG9hZGluZ1N0YXR1cywgdXNlTWFwLCB1c2VNYXBzTGlicmFyeSwgdXNlTWFya2VyUmVmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n");

/***/ })

};
;